import lupa
from lupa import LuaRuntime
import logging
import subprocess
import os
import tempfile
import re
import binascii
import requests
import base64
import hashlib
from typing import Optional, Tuple, List

# –õ–æ–≥–≥–µ—Ä
logger = logging.getLogger("DeobfuscatorEngine")

class DeobfuscatorEngine:
    def __init__(self):
        base_dir = os.path.dirname(os.path.abspath(__file__))
        self.unluac_path = os.path.join(base_dir, "unluac.jar")
        self.http_cache = {}  # –ö–µ—à –¥–ª—è HTTP –∑–∞–ø—Ä–æ—Å–æ–≤
        logger.info(f"üìÅ Working Dir: {base_dir}")

    # ==========================================
    # PRE-PROCESSING: –î–ï–¢–ï–ö–¶–ò–Ø –ò –î–ï–ö–û–î–ò–†–û–í–ê–ù–ò–ï
    # ==========================================
    
    def _detect_and_decode(self, content: bytes) -> Tuple[bytes, List[str]]:
        """
        –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π –∞–Ω–∞–ª–∏–∑ –∏ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç: (decoded_content, detection_log)
        """
        detection_log = []
        
        try:
            text = content.decode('utf-8', 'ignore')
        except:
            return content, ["‚ö†Ô∏è Binary content, skipping pre-processing"]
        
        original_text = text
        
        # === STAGE 1: BASE64 DETECTION ===
        # –ò—â–µ–º –±–æ–ª—å—à–∏–µ base64 –±–ª–æ–∫–∏ (–º–∏–Ω–∏–º—É–º 100 —Å–∏–º–≤–æ–ª–æ–≤)
        base64_pattern = r'[A-Za-z0-9+/]{100,}={0,2}'
        base64_matches = re.findall(base64_pattern, text)
        
        if base64_matches:
            detection_log.append(f"üîç Found {len(base64_matches)} Base64 blocks")
            for i, b64_str in enumerate(base64_matches[:5]):  # –õ–∏–º–∏—Ç 5 –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
                try:
                    decoded = base64.b64decode(b64_str)
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –≤–∞–ª–∏–¥–Ω—ã–π Lua –∫–æ–¥
                    if b'local' in decoded or b'function' in decoded or b'return' in decoded:
                        text = text.replace(b64_str, f'--[[BASE64_DECODED_{i}]]--\n{decoded.decode("utf-8", "ignore")}')
                        detection_log.append(f"  ‚úÖ Decoded Base64 block {i} ({len(decoded)} bytes)")
                except:
                    pass
        
        # === STAGE 2: HEX STRING DETECTION ===
        # –ü–∞—Ç—Ç–µ—Ä–Ω: "\\x48\\x65\\x6c\\x6c\\x6f" –∏–ª–∏ "\x48\x65\x6c\x6c\x6f"
        hex_pattern = r'\\x[0-9a-fA-F]{2}'
        if re.search(hex_pattern, text):
            detection_log.append("üîç Found Hex-encoded strings")
            
            def hex_replace(match):
                hex_str = match.group(0)
                try:
                    char = chr(int(hex_str[2:], 16))
                    return char
                except:
                    return hex_str
            
            text = re.sub(hex_pattern, hex_replace, text)
            detection_log.append("  ‚úÖ Decoded Hex strings")
        
        # === STAGE 3: ASCII ARRAY DETECTION ===
        # –ü–∞—Ç—Ç–µ—Ä–Ω: {72,101,108,108,111} –∏–ª–∏ {0x48,0x65,0x6c,0x6c,0x6f}
        ascii_pattern = r'\{(\s*\d{1,3}\s*,\s*){10,}\d{1,3}\s*\}'
        ascii_matches = re.finditer(ascii_pattern, text)
        
        for match in ascii_matches:
            try:
                array_str = match.group(0)
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —á–∏—Å–ª–∞
                numbers = re.findall(r'\d+', array_str)
                # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å—Ç—Ä–æ–∫—É
                decoded_str = ''.join(chr(int(n)) for n in numbers if 0 <= int(n) <= 255)
                
                # –ï—Å–ª–∏ –ø–æ–ª—É—á–∏–ª–∞—Å—å —á–∏—Ç–∞–µ–º–∞—è —Å—Ç—Ä–æ–∫–∞
                if len(decoded_str) > 5 and all(32 <= ord(c) <= 126 or c in '\n\r\t' for c in decoded_str[:20]):
                    text = text.replace(array_str, f'"{decoded_str}"')
                    detection_log.append(f"  ‚úÖ Decoded ASCII array: {decoded_str[:30]}...")
            except:
                pass
        
        # === STAGE 4: XOR PATTERN DETECTION ===
        # –ò—â–µ–º —Ç–∏–ø–∏—á–Ω—ã–µ XOR –ø–∞—Ç—Ç–µ—Ä–Ω—ã
        xor_patterns = [
            r'bit\.bxor\s*\(',
            r'bit32\.bxor\s*\(',
            r'string\.char\s*\(\s*bit',
        ]
        
        for pattern in xor_patterns:
            if re.search(pattern, text):
                detection_log.append("üîç Detected XOR encryption (will be handled in Lua runtime)")
                break
        
        # === STAGE 5: ROT13/CAESAR DETECTION ===
        # –ü—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞: –µ—Å–ª–∏ –µ—Å—Ç—å gsub —Å —á–∏—Å–ª–æ–≤—ã–º–∏ –æ–ø–µ—Ä–∞—Ü–∏—è–º–∏ –Ω–∞ –±–∞–π—Ç–∞—Ö
        if re.search(r':gsub\s*\([^)]*function.*?:byte\(\)', text):
            detection_log.append("üîç Detected character substitution cipher")
        
        # === STAGE 6: ESCAPED UNICODE ===
        # –ü–∞—Ç—Ç–µ—Ä–Ω: \u0048\u0065\u006c\u006c\u006f
        unicode_pattern = r'\\u([0-9a-fA-F]{4})'
        if re.search(unicode_pattern, text):
            def unicode_replace(match):
                try:
                    return chr(int(match.group(1), 16))
                except:
                    return match.group(0)
            
            text = re.sub(unicode_pattern, unicode_replace, text)
            detection_log.append("  ‚úÖ Decoded Unicode escapes")
        
        # === STAGE 7: OBFUSCATED FUNCTION NAMES ===
        # –ò—â–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Ç–∏–ø–∞: _0x1a2b3c, __LLILIL__
        obf_name_pattern = r'\b(_+[0-9a-fA-F]{6,}|_+[IL]{6,})\b'
        obf_names = set(re.findall(obf_name_pattern, text))
        if obf_names:
            detection_log.append(f"üîç Found {len(obf_names)} obfuscated identifiers")
        
        # –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç –∏–∑–º–µ–Ω–∏–ª—Å—è - —ç—Ç–æ —É—Å–ø–µ—Ö
        if text != original_text:
            detection_log.append(f"‚ú® Pre-processing: {len(original_text)} -> {len(text)} chars")
            return text.encode('utf-8'), detection_log
        
        return content, detection_log

    # ==========================================
    # ENHANCED LUA ENVIRONMENT
    # ==========================================
    
    def _create_lua_environment(self) -> str:
        """–°–æ–∑–¥–∞–µ—Ç —É–ª—É—á—à–µ–Ω–Ω–æ–µ Lua –æ–∫—Ä—É–∂–µ–Ω–∏–µ —Å –¥–µ–∫–æ–¥–µ—Ä–∞–º–∏"""
        
        return """
        -- ==========================================
        -- AUTO-DECODERS (–í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –≤ —Å—Ä–µ–¥—É)
        -- ==========================================
        
        -- –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –∫–ª—é—á–µ–π
        _G.DETECTED_KEYS = {}
        _G.DECODED_PAYLOADS = {}
        
        -- === BASE64 DECODER ===
        local b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        function _G.base64_decode(data)
            data = string.gsub(data, '[^'..b64chars..'=]', '')
            return (data:gsub('.', function(x)
                if (x == '=') then return '' end
                local r,f='',(b64chars:find(x)-1)
                for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
                return r;
            end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
                if (#x ~= 8) then return '' end
                local c=0
                for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
                return string.char(c)
            end))
        end
        
        -- === HEX DECODER ===
        function _G.hex_decode(str)
            return (str:gsub('..', function(cc)
                return string.char(tonumber(cc, 16))
            end))
        end
        
        -- === XOR DECODER ===
        function _G.xor_decrypt(data, key)
            local result = {}
            local key_len = #key
            for i = 1, #data do
                local data_byte = data:byte(i)
                local key_byte = key:byte(((i - 1) % key_len) + 1)
                table.insert(result, string.char(bit.bxor(data_byte, key_byte)))
            end
            return table.concat(result)
        end
        
        -- === BITWISE OPERATIONS ===
        local bit = {}
        function bit.tobit(x) x = x % 4294967296; if x >= 2147483648 then x = x - 4294967296 end; return x end
        function bit.bnot(x) return 4294967295 - x % 4294967296 end
        local function bit_oper(a, b, oper)
            local r, m, s = 0, 2^31, nil
            repeat s,a,b = a+b+m, a%m, b%m; r,m = r + m*oper%(s-a-b), m/2 until m < 1
            return r
        end
        function bit.band(a, b) return bit_oper(a, b, 4) end
        function bit.bor(a, b)  return bit_oper(a, b, 1) end
        function bit.bxor(a, b) return bit_oper(a, b, 3) end
        function bit.lshift(a, b) return (a * 2^b) % 4294967296 end
        function bit.rshift(a, b) return math.floor(a / 2^b) % 4294967296 end
        function bit.arshift(a, b) 
            local z = math.floor(a / 2^b) % 4294967296
            if a >= 2147483648 then z = z + 4294967296 - 2^(32-b) end
            return z
        end
        package.loaded.bit = bit
        _G.bit = bit
        _G.bit32 = bit
        
        -- ==========================================
        -- GLOBAL STORAGE & LOGGING
        -- ==========================================
        _G.CAPTURED_CHUNKS = {}
        _G.DETECTED_STRINGS = {}
        _G.ACTION_LOG = {}
        _G.FINAL_GLOBALS = {}
        _G.LOADSTRING_DEPTH = 0
        _G.MAX_LOADSTRING_DEPTH = 10
        
        local function log_action(msg)
            if #_G.ACTION_LOG < 2000 then 
                table.insert(_G.ACTION_LOG, msg) 
            end
        end
        
        -- ==========================================
        -- ROBLOX API EMULATION
        -- ==========================================
        local function CreateSignal()
            return { 
                Connect = function(f) return {Disconnect=function() end} end, 
                Fire = function(...) end, 
                Wait = function() return 0 end 
            }
        end
        
        _G.Instance = {}
        function _G.Instance.new(className, parent)
            local obj = {}
            obj.ClassName = className or "Folder"
            obj.Name = className or "Folder"
            obj.Parent = parent
            obj.Archivable = true
            obj.Changed = CreateSignal()
            obj.ChildAdded = CreateSignal()
            
            function obj:Destroy() end
            function obj:Clone() return self end
            function obj:ClearAllChildren() end
            function obj:FindFirstChild(n) return nil end
            function obj:WaitForChild(n, t) return _G.Instance.new("Folder", obj) end
            function obj:GetChildren() return {} end
            function obj:GetDescendants() return {} end
            function obj:GetService(name)
                if _G.game[name] then return _G.game[name] end
                return _G.Instance.new(name, _G.game)
            end
            
            local mt = {
                __index = function(t, k)
                    if k == "Value" then return "MockValue" end
                    return rawget(t, k)
                end,
                __newindex = rawset,
                __tostring = function(t) return t.Name end
            }
            return setmetatable(obj, mt)
        end
        
        -- Data types
        _G.Vector3 = { new = function(x,y,z) return {X=x or 0, Y=y or 0, Z=z or 0} end, zero={X=0,Y=0,Z=0} }
        _G.CFrame = { new = function(...) return {p=_G.Vector3.new()} end, Angles=function(...) return {} end }
        _G.UDim2 = { new = function(...) return {} end, fromScale=function(...) return {} end }
        _G.Color3 = { new = function(...) return {} end, fromRGB=function(...) return {} end }
        _G.Enum = setmetatable({}, { __index = function() return setmetatable({}, {__index=function() return 1 end}) end })
        
        -- Task library
        _G.task = { 
            wait = function(t) return t or 0 end, 
            spawn = function(f) pcall(f) end, 
            delay = function(t,f) pcall(f) end, 
            defer = function(f) pcall(f) end 
        }
        _G.wait = _G.task.wait
        _G.spawn = _G.task.spawn
        
        -- Game hierarchy
        _G.game = _G.Instance.new("DataModel")
        _G.game.Players = _G.Instance.new("Players", _G.game)
        _G.game.Players.LocalPlayer = _G.Instance.new("Player", _G.game.Players)
        _G.game.Players.LocalPlayer.Name = "DeobfuscatorUser"
        _G.game.Players.LocalPlayer.UserId = 2652366
        _G.workspace = _G.Instance.new("Workspace", _G.game)
        _G.game.HttpService = _G.Instance.new("HttpService", _G.game)
        _G.game.HttpService.JSONDecode = function(s, t) return {} end
        _G.game.HttpService.JSONEncode = function(s, t) return "{}" end
        _G.script = _G.Instance.new("Script", _G.game.workspace)
        
        -- ==========================================
        -- NETWORK EMULATION
        -- ==========================================
        local function handle_network_response(url, content)
            if content and #content > 0 then
                log_action("   ‚úÖ HTTP 200: " .. #content .. " bytes")
                
                if #content > 50 then
                    table.insert(_G.CAPTURED_CHUNKS, {
                        data = content, 
                        size = #content, 
                        type = "http_response",
                        url = url
                    })
                    table.insert(_G.DETECTED_STRINGS, "HTTP_URL: " .. url)
                    
                    -- –ü—Ä–æ–±—É–µ–º –∞–≤—Ç–æ–¥–µ–∫–æ–¥–∏–Ω–≥
                    local decoded = nil
                    
                    -- –ü—Ä–æ–±–∞ Base64
                    pcall(function()
                        decoded = base64_decode(content)
                        if decoded and #decoded > 10 then
                            log_action("   üîì Auto-decoded Base64 from HTTP response")
                            table.insert(_G.DECODED_PAYLOADS, {source="http_base64", data=decoded})
                        end
                    end)
                end
                return content
            else
                log_action("   ‚ùå HTTP Error/Empty")
                return ""
            end
        end
        
        _G.game.HttpGet = function(self, url) 
            log_action("üåç HTTP GET: " .. tostring(url)) 
            local success, res = pcall(PYTHON_HTTP_GET, url)
            if success then 
                return handle_network_response(url, res)
            end
            return "" 
        end
        _G.game.HttpGetAsync = _G.game.HttpGet
        
        local function emulation_request(options)
            local url = options.Url or options.url
            if not url then return {Success=false} end
            
            log_action("üåç SYN.REQUEST: " .. tostring(url))
            local body = _G.game:HttpGet(url)
            
            return {
                Body = body,
                StatusCode = (body ~= "") and 200 or 404,
                Success = (body ~= ""),
                StatusMessage = "OK"
            }
        end
        
        -- ==========================================
        -- EXPLOIT ENVIRONMENT
        -- ==========================================
        _G.request = emulation_request
        _G.http_request = emulation_request
        _G.syn = { 
            request = emulation_request,
            protect_gui = function() end,
            queue_on_teleport = function() end
        }
        
        _G.identifyexecutor = function() return "Synapse X", "2.0.0" end
        _G.getexecutorname = function() return "Synapse X" end
        _G.getgenv = function() return _G end
        _G.getrenv = function() return _G end
        _G.getreg = function() return {} end
        _G.getgc = function() return {} end
        _G.checkcaller = function() return true end
        _G.islclosure = function() return true end
        _G.newcclosure = function(f) return f end
        _G.hookfunction = function(old, new) return old end
        
        -- Filesystem stubs
        _G.writefile = function(path, data) log_action("üíæ writefile: "..tostring(path)) end
        _G.readfile = function(path) return "" end
        _G.isfile = function(path) return false end
        _G.delfile = function(path) end
        _G.makefolder = function(path) end
        
        -- ==========================================
        -- ENHANCED SPYWARE HOOKS
        -- ==========================================
        local function capture_str(s) 
            if type(s) == "string" and #s > 4 then 
                if not s:find("stack begin") and not s:find("upvalue") and not s:find("^%s*$") then
                    _G.DETECTED_STRINGS[s] = true 
                end
            end 
            return s
        end
        
        -- Hook string.char (—Å –¥–µ—Ç–µ–∫—Ü–∏–µ–π –º–∞—Å—Å–æ–≤–æ–π –¥–µ—à–∏—Ñ—Ä–æ–≤–∫–∏)
        local real_char = string.char
        string.char = function(...)
            local args = {...}
            if #args > 10 then
                local res = real_char(...)
                capture_str(res)
                
                -- –õ–æ–≥–∏—Ä—É–µ–º –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ XOR –∫–ª—é—á–∏
                if #args < 50 then
                    table.insert(_G.DETECTED_KEYS, table.concat(args, ","))
                end
                return res
            end
            return real_char(...)
        end
        
        -- Hook table.concat
        local real_concat = table.concat
        table.concat = function(t, sep, i, j)
            local res = real_concat(t, sep, i, j)
            capture_str(res)
            return res
        end
        
        -- Hook string.byte (–¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è XOR –æ–ø–µ—Ä–∞—Ü–∏–π)
        local real_byte = string.byte
        string.byte = function(s, i, j)
            if type(s) == "string" and #s > 20 and not i and not j then
                log_action("üîë Potential XOR key scan: " .. s:sub(1, 20))
            end
            return real_byte(s, i, j)
        end
        
        -- RECURSIVE LOADSTRING HOOK (–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–æ!)
        local real_load = load
        local function hooked_load(chunk, name, mode, env)
            _G.LOADSTRING_DEPTH = _G.LOADSTRING_DEPTH + 1
            
            if _G.LOADSTRING_DEPTH > _G.MAX_LOADSTRING_DEPTH then
                log_action("‚ö†Ô∏è Max loadstring depth reached - preventing infinite recursion")
                _G.LOADSTRING_DEPTH = _G.LOADSTRING_DEPTH - 1
                return function() end
            end
            
            if type(chunk) == "string" and #chunk > 50 then
                table.insert(_G.CAPTURED_CHUNKS, {
                    data = chunk, 
                    size = #chunk, 
                    type = "load_string",
                    depth = _G.LOADSTRING_DEPTH
                })
                log_action("üî• Captured Chunk [Depth " .. _G.LOADSTRING_DEPTH .. "] Size: " .. #chunk)
                
                -- –ü—Ä–æ–±—É–µ–º —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –≤—ã–ø–æ–ª–Ω–∏—Ç—å, —á—Ç–æ–±—ã —Ä–∞—Å–ø–∞–∫–æ–≤–∞—Ç—å –≤–ª–æ–∂–µ–Ω–Ω—ã–µ loadstring
                local func = real_load(chunk, name, mode, env or _G)
                if func then
                    pcall(func)  -- –í—ã–ø–æ–ª–Ω—è–µ–º, —á—Ç–æ–±—ã —Ç—Ä–∏–≥–≥–µ—Ä–Ω—É—Ç—å —Å–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å
                end
            end
            
            _G.LOADSTRING_DEPTH = _G.LOADSTRING_DEPTH - 1
            return real_load(chunk, name, mode, env)
        end
        
        _G.load = hooked_load
        _G.loadstring = hooked_load
        
        -- –§—É–Ω–∫—Ü–∏—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –¥–∞–º–ø–∞
        function _G.dump_globals()
            local ignore = {
                string=1, math=1, table=1, bit=1, bit32=1, pairs=1, ipairs=1, next=1, _G=1, 
                package=1, os=1, io=1, Instance=1, Vector3=1, CFrame=1, UDim2=1, Color3=1,
                Enum=1, task=1, wait=1, spawn=1, delay=1, defer=1, game=1, workspace=1,
                script=1, getgenv=1, getrenv=1, getreg=1, getgc=1, checkcaller=1,
                islclosure=1, newcclosure=1, load=1, loadstring=1, print=1, warn=1, error=1,
                tostring=1, tonumber=1, type=1, pcall=1, xpcall=1, select=1, unpack=1,
                setmetatable=1, getmetatable=1, require=1, syn=1, request=1, http_request=1,
                identifyexecutor=1, getexecutorname=1, hookfunction=1, writefile=1, readfile=1,
                isfile=1, delfile=1, makefolder=1, PYTHON_HTTP_GET=1,
                DETECTED_STRINGS=1, CAPTURED_CHUNKS=1, ACTION_LOG=1, FINAL_GLOBALS=1,
                LOADSTRING_DEPTH=1, MAX_LOADSTRING_DEPTH=1, DETECTED_KEYS=1, DECODED_PAYLOADS=1,
                base64_decode=1, hex_decode=1, xor_decrypt=1
            }
            for k, v in pairs(getfenv()) do
                if not ignore[k] then
                    if type(v) == "string" or type(v) == "number" or type(v) == "boolean" then
                        table.insert(_G.FINAL_GLOBALS, tostring(k) .. " = " .. tostring(v))
                    end
                end
            end
        end
        """

    def process(self, content, status_callback=None):
        def update_status(msg):
            if status_callback: status_callback(msg)
            logger.info(f"[STATUS] {msg}")

        if not self._check_java():
            return b"-- [FATAL] Java is missing. Install Java to use unluac."

        # === STAGE 1: PRE-PROCESSING ===
        update_status("üî¨ –ê–Ω–∞–ª–∏–∑ –∏ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ...")
        decoded_content, detection_log = self._detect_and_decode(content)
        
        for log_entry in detection_log:
            update_status(log_entry)

        update_status("üß† –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ä–µ–¥—ã Roblox (V3 Enhanced)...")

        # === STAGE 2: LUA VM SETUP ===
        try:
            lua = LuaRuntime(unpack_returned_tuples=True, encoding=None)
        except Exception as e:
            return f"-- [FATAL] Lua start error: {e}".encode('utf-8')

        # HTTP Bridge
        def py_http_get(url):
            try:
                url = str(url).strip()
                
                # Whitelist check
                allowed_domains = ['pastebin.com', 'raw.githubusercontent.com', 'rentry.co', 'hastebin.com']
                if not any(domain in url for domain in allowed_domains):
                    logger.warning(f"Blocked URL (not in whitelist): {url}")
                    return ""
                
                # Cache check
                url_hash = hashlib.md5(url.encode()).hexdigest()
                if url_hash in self.http_cache:
                    update_status(f"üíæ Cache hit: {url[:40]}...")
                    return self.http_cache[url_hash]
                
                headers = {
                    "User-Agent": "Roblox/WinInet",
                    "Accept": "text/plain"
                }
                update_status(f"üåê GET: {url[:50]}...")
                response = requests.get(url, headers=headers, timeout=10, allow_redirects=True)
                
                if response.status_code == 200:
                    # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ (–∑–∞—â–∏—Ç–∞ –æ—Ç DoS)
                    content = response.text[:500000]  # Max 500KB
                    self.http_cache[url_hash] = content
                    return content
                return ""
            except Exception as e:
                logger.error(f"HTTP Error: {e}")
                return ""

        lua.globals().PYTHON_HTTP_GET = py_http_get

        # === STAGE 3: EXECUTION ===
        try:
            update_status("üå™Ô∏è –ó–∞–ø—É—Å–∫ —Å —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–æ–π...")
            
            lua_env = self._create_lua_environment()
            lua.execute(lua_env)
            
            runner = lua.eval("""
                function(code)
                    local status, err = pcall(function()
                        local f, load_err = load(code, "script", "t", _G)
                        if not f then error(load_err) end
                        f()
                    end)
                    
                    if not status then
                        table.insert(_G.ACTION_LOG, "‚ùå Script Error: " .. tostring(err))
                    end
                    
                    pcall(_G.dump_globals)
                    return true
                end
            """)
            
            runner(decoded_content)

            # === STAGE 4: RESULTS COLLECTION ===
            strings_tbl = lua.globals().DETECTED_STRINGS
            detected_strings = []
            if strings_tbl:
                for k in strings_tbl:
                    detected_strings.append(str(k))
            
            global_dump = list(lua.globals().FINAL_GLOBALS)
            action_log = list(lua.globals().ACTION_LOG)
            chunks = lua.globals().CAPTURED_CHUNKS
            detected_keys = list(lua.globals().DETECTED_KEYS)
            decoded_payloads = lua.globals().DECODED_PAYLOADS
            
            # –ü–æ–∏—Å–∫ –ª—É—á—à–µ–≥–æ —á–∞–Ω–∫–∞ (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç: –≥–ª—É–±–∏–Ω–∞ loadstring > http_response > —Ä–∞–∑–º–µ—Ä)
            best_chunk = None
            max_score = 0
            
            if len(chunks) > 0:
                for i in range(1, len(chunks) + 1):
                    c = chunks[i]
                    score = c.size
                    
                    # –ü—Ä–∏–æ—Ä–∏—Ç–µ–∑–∞—Ü–∏—è
                    if c.type == "load_string":
                        score *= (1.5 + c.depth * 0.2)  # –ì–ª—É–±–∂–µ = –ª—É—á—à–µ
                    elif c.type == "http_response":
                        score *= 1.3
                    
                    if score > max_score:
                        max_score = score
                        best_chunk = c.data
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º decoded_payloads
            if decoded_payloads and len(decoded_payloads) > 0:
                for i in range(1, len(decoded_payloads) + 1):
                    payload = decoded_payloads[i]
                    if len(payload.data) > max_score:
                        best_chunk = payload.data
                        update_status(f"‚ú® –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –∞–≤—Ç–æ–¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π payload!")
            
            target_code = best_chunk if best_chunk else decoded_content
            
            if best_chunk:
                update_status(f"üéâ –ù–∞–π–¥–µ–Ω —Å–∫—Ä—ã—Ç—ã–π –∫–æ–¥ ({len(str(best_chunk))} bytes)!")

            return self._finalize_output(
                target_code, 
                detected_strings, 
                global_dump, 
                action_log, 
                detected_keys,
                detection_log,
                update_status
            )

        except Exception as e:
            logger.error(f"Engine Crash: {e}", exc_info=True)
            return f"-- [CRASH ERROR]: {str(e)}".encode('utf-8')

    def _check_java(self):
        try:
            subprocess.run(["java", "-version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return True
        except: 
            return False

    def _clean_string(self, s):
        if isinstance(s, bytes):
            try: return s.decode('utf-8')
            except: return str(s)
        return str(s)

    def _finalize_output(self, code_bytes, strings, globals_dump, logs, keys, pre_log, callback):
        if callback: callback("üß¨ –§–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è...")
        
        if isinstance(code_bytes, str):
            code_bytes = code_bytes.encode('utf-8', 'ignore')

        decompiled = self._try_decompile(code_bytes)
        
        final_text = "-- " + "="*70 + "\n"
        final_text += "-- ROBLOX DEOBFUSCATOR V3 - ENHANCED EDITION\n"
        final_text += "-- " + "="*70 + "\n\n"
        
        # Pre-processing log
        if pre_log:
            final_text += "-- [[ PRE-PROCESSING ANALYSIS ]] --\n"
            for entry in pre_log:
                final_text += f"-- {entry}\n"
            final_text += "\n"
        
        # Detected keys (XOR, etc.)
        if keys:
            final_text += "-- [[ DETECTED ENCRYPTION KEYS ]] --\n"
            for key in keys[:10]:  # –õ–∏–º–∏—Ç 10
                final_text += f"-- {self._clean_string(key)}\n"
            final_text += "\n"
        
        # Strings
        final_text += "-- [[ DUMPED STRINGS ]] --\n"
        sorted_strings = sorted(strings, key=lambda x: len(str(x)), reverse=True)
        seen = set()
        for s in sorted_strings[:100]:  # –õ–∏–º–∏—Ç 100
            clean = self._clean_string(s).replace('\n', ' ').replace('\r', '')
            if clean not in seen and len(clean) > 3:
                final_text += f'-- "{clean}"\n'
                seen.add(clean)
        
        # Globals
        if globals_dump:
            final_text += "\n-- [[ GLOBALS ]] --\n"
            for g in globals_dump:
                final_text += f"-- {self._clean_string(g)}\n"
        
        # Execution log
        if logs:
            final_text += "\n-- [[ EXECUTION LOG ]] --\n"
            for l in logs[-50:]:  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 50
                final_text += f"-- {self._clean_string(l)}\n"
        
        final_text += "\n" + "-- " + "="*70 + "\n"
        final_text += "-- DECOMPILED SOURCE CODE\n"
        final_text += "-- " + "="*70 + "\n\n"
        
        if decompiled:
            try: 
                src = decompiled.decode('utf-8', 'ignore')
            except: 
                src = decompiled.decode('latin-1', 'ignore')
            final_text += self._beautify_lua(src)
        else:
            final_text += "-- [INFO] Decompilation skipped (source is already readable)\n\n"
            try: 
                final_text += code_bytes.decode('utf-8')
            except: 
                final_text += "-- [Binary Data]\n"
                final_text += str(binascii.hexlify(code_bytes[:500])) + "...\n"

        return final_text.encode('utf-8')

    def _try_decompile(self, bytecode):
        # –ï—Å–ª–∏ —ç—Ç–æ —Ç–µ–∫—Å—Ç, –Ω–µ –¥–µ–∫–æ–º–ø–∏–ª–∏—Ä—É–µ–º
        if bytecode.startswith(b"--") or b"local " in bytecode or b"function" in bytecode:
            return None

        if not os.path.exists(self.unluac_path): 
            return None
        
        try:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".luac", mode='wb') as tmp:
                tmp.write(bytecode)
                path = tmp.name
            
            res = subprocess.run(
                ["java", "-Xmx1G", "-jar", self.unluac_path, path], 
                capture_output=True, 
                timeout=15
            )
            os.remove(path)
            
            if res.returncode == 0 and len(res.stdout) > 0: 
                return res.stdout
            return None
        except: 
            return None

    def _beautify_lua(self, source_code):
        # –ü—Ä–æ—Å—Ç–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        source_code = re.sub(r'(\s)(local|return|if|for|while|repeat|function)(\s)', r'\n\2 ', source_code)
        replacements = {
            " then ": " then\n    ",
            " do ": " do\n    ",
            " end": "\nend",
            " repeat ": "\nrepeat\n    ",
            " until ": "\nuntil ",
            ";": ";\n"
        }
        for k, v in replacements.items():
            source_code = source_code.replace(k, v)
        return source_code
