import lupa
from lupa import LuaRuntime
import logging
import os
import re
import binascii

logger = logging.getLogger("DeobfuscatorEngine")

class DeobfuscatorEngine:
    def __init__(self):
        base_dir = os.path.dirname(os.path.abspath(__file__))
        logger.info(f"üìÅ Working Dir: {base_dir}")

    def process(self, content, status_callback=None):
        def update_status(msg):
            if status_callback: status_callback(msg)
            logger.info(f"[STATUS] {msg}")

        update_status("üß† –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–π —Å—Ä–µ–¥—ã Luau (Emulation V4)...")

        try:
            lua = LuaRuntime(unpack_returned_tuples=True, encoding=None)
        except Exception as e:
            return f"-- [FATAL] Lua start error: {e}".encode('utf-8')

        # ==========================================
        # –†–ê–°–®–ò–†–ï–ù–ù–ê–Ø –≠–ú–£–õ–Ø–¶–ò–Ø –° –ì–õ–£–ë–û–ö–ò–ú –ü–ï–†–ï–•–í–ê–¢–û–ú
        # ==========================================
        
        advanced_env = """
        -- ============================================
        -- BITWISE OPERATIONS (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –æ–±—Ñ—É—Å–∫–∞—Ü–∏–∏)
        -- ============================================
        local bit = {}
        function bit.tobit(x) 
            x = x % 4294967296
            if x >= 2147483648 then x = x - 4294967296 end
            return x 
        end
        function bit.bnot(x) return (-1 - x) % 4294967296 end
        function bit.tohex(x, n)
            n = n or 8
            local up
            if n <= 0 then
                if n == 0 then return '' end
                up = true
                n = - n
            end
            x = bit.band(x, 16^n-1)
            return ('%0'..n..(up and 'X' or 'x')):format(x)
        end
        
        local function bit_oper(a, b, oper)
            local r, m = 0, 2^31
            repeat
                local aa, bb = a % m, b % m
                r = r + m * oper % (aa + bb - aa * bb / m)
                a, b, m = (a - aa) / 2, (b - bb) / 2, m / 2
            until m < 1
            return r
        end
        
        function bit.band(a, b) return bit_oper(a, b, 1) end
        function bit.bor(a, b) return bit_oper(a, b, 7) end
        function bit.bxor(a, b) return bit_oper(a, b, 6) end
        function bit.lshift(a, n) return (a * 2^n) % 4294967296 end
        function bit.rshift(a, n) return math.floor(a / 2^n) % 4294967296 end
        function bit.arshift(a, n)
            if a >= 2147483648 then
                a = a - 4294967296
            end
            return math.floor(a / 2^n)
        end
        function bit.rol(x, n) return bit.lshift(x, n) + bit.rshift(x, 32 - n) end
        function bit.ror(x, n) return bit.rshift(x, n) + bit.lshift(x, 32 - n) end
        
        package.loaded.bit = bit
        package.loaded.bit32 = bit
        _G.bit = bit
        _G.bit32 = bit

        -- ============================================
        -- –°–ò–°–¢–ï–ú–ê –ü–ï–†–ï–•–í–ê–¢–ê (–¢–†–ï–ö–ò–ù–ì)
        -- ============================================
        _G.CAPTURED_CHUNKS = {}
        _G.DETECTED_STRINGS = {}
        _G.REMOTE_CALLS = {}
        _G.ACTION_LOG = {}
        _G.FINAL_GLOBALS = {}
        _G.FUNCTION_CALLS = {}
        _G.DECRYPTED_DATA = {}
        
        local function log_action(msg)
            if #_G.ACTION_LOG < 1000 then
                table.insert(_G.ACTION_LOG, tostring(msg))
            end
        end

        local function capture_string(s)
            if type(s) == "string" and #s > 2 and #s < 10000 then
                -- –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Å—Ç—Ä–æ–∫–∏ Lua VM
                local skip = {
                    "stack begin", "upvalue", "function", "table", "userdata",
                    "thread", "proto", "light userdata", "nil"
                }
                local should_skip = false
                for _, pattern in ipairs(skip) do
                    if s:find(pattern) then
                        should_skip = true
                        break
                    end
                end
                
                if not should_skip then
                    _G.DETECTED_STRINGS[s] = (_G.DETECTED_STRINGS[s] or 0) + 1
                end
            end
            return s
        end

        -- ============================================
        -- –ü–ï–†–ï–•–í–ê–¢ STRING –û–ü–ï–†–ê–¶–ò–ô
        -- ============================================
        local string_mt = getmetatable("")
        local real_string = {}
        
        -- –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        for k, v in pairs(string) do
            real_string[k] = v
        end
        
        -- –•—É–∫ string.char (—Å–∞–º–æ–µ —á–∞—Å—Ç–æ–µ –≤ –¥–µ–æ–±—Ñ—É—Å–∫–∞—Ü–∏–∏)
        string.char = function(...)
            local args = {...}
            local result = real_string.char(...)
            
            -- –õ–æ–≥–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –∑–Ω–∞—á–∏–º—ã–µ –≤—ã–∑–æ–≤—ã
            if #args > 1 then
                capture_string(result)
                log_action("üî° string.char(" .. #args .. " bytes) -> " .. (#result > 50 and (#result .. " bytes") or '"' .. result .. '"'))
            end
            
            return result
        end
        
        -- –•—É–∫ string.byte
        string.byte = function(s, i, j)
            capture_string(s)
            return real_string.byte(s, i, j)
        end
        
        -- –•—É–∫ string.sub
        string.sub = function(s, i, j)
            local result = real_string.sub(s, i, j)
            if #result > 10 then
                capture_string(result)
            end
            return result
        end
        
        -- –•—É–∫ string.gsub
        string.gsub = function(s, pattern, repl, n)
            local result, count = real_string.gsub(s, pattern, repl, n)
            if count > 0 and #result > 10 then
                capture_string(result)
                log_action("üîÑ gsub: " .. count .. " replacements")
            end
            return result, count
        end
        
        -- –•—É–∫ table.concat
        local real_concat = table.concat
        table.concat = function(t, sep, i, j)
            local result = real_concat(t, sep, i, j)
            if type(result) == "string" and #result > 10 then
                capture_string(result)
            end
            return result
        end

        -- ============================================
        -- –ü–ï–†–ï–•–í–ê–¢ –ó–ê–ì–†–£–ó–ö–ò –ö–û–î–ê
        -- ============================================
        local real_load = load or loadstring
        local load_count = 0
        
        local function hooked_load(chunk, chunkname, mode, env)
            load_count = load_count + 1
            
            if type(chunk) == "string" then
                local size = #chunk
                
                -- –ó–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ —á–∞–Ω–∫–∏ > 100 –±–∞–π—Ç
                if size > 100 then
                    table.insert(_G.CAPTURED_CHUNKS, {
                        data = chunk,
                        size = size,
                        name = chunkname or ("chunk_" .. load_count),
                        type = "string"
                    })
                    log_action("üî• Captured chunk #" .. load_count .. ": " .. size .. " bytes")
                    capture_string(chunk)
                end
            elseif type(chunk) == "function" then
                log_action("üî• load() called with function (bytecode loader)")
                table.insert(_G.CAPTURED_CHUNKS, {
                    data = "<function>",
                    size = 0,
                    name = chunkname or ("func_chunk_" .. load_count),
                    type = "function"
                })
            end
            
            return real_load(chunk, chunkname, mode, env)
        end
        
        load = hooked_load
        loadstring = hooked_load
        _G.load = hooked_load
        _G.loadstring = hooked_load

        -- ============================================
        -- –†–ê–°–®–ò–†–ï–ù–ù–ê–Ø ROBLOX API
        -- ============================================
        
        -- Signal (—Å–æ–±—ã—Ç–∏—è)
        local function CreateSignal()
            local sig = {}
            local connections = {}
            
            function sig:Connect(callback)
                local conn = {
                    Connected = true,
                    Disconnect = function(self)
                        self.Connected = false
                        for i, c in ipairs(connections) do
                            if c == conn then
                                table.remove(connections, i)
                                break
                            end
                        end
                    end
                }
                table.insert(connections, {callback = callback, conn = conn})
                return conn
            end
            
            function sig:Fire(...)
                for _, data in ipairs(connections) do
                    if data.conn.Connected then
                        pcall(data.callback, ...)
                    end
                end
            end
            
            function sig:Wait()
                coroutine.yield()
                return nil
            end
            
            return sig
        end

        -- Instance (–±–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –æ–±—ä–µ–∫—Ç–æ–≤)
        _G.Instance = {}
        _G.Instance.__index = _G.Instance
        
        function _G.Instance.new(className, parent)
            local obj = setmetatable({}, _G.Instance)
            obj.ClassName = className or "Part"
            obj.Name = className or "Instance"
            obj.Parent = parent
            obj.Archivable = true
            obj.Changed = CreateSignal()
            obj.ChildAdded = CreateSignal()
            obj.ChildRemoved = CreateSignal()
            obj.AncestryChanged = CreateSignal()
            obj.Destroying = CreateSignal()
            
            function obj:Destroy()
                self.Destroying:Fire()
                self.Parent = nil
            end
            
            function obj:Clone()
                return _G.Instance.new(self.ClassName, self.Parent)
            end
            
            function obj:ClearAllChildren() end
            function obj:GetChildren() return {} end
            function obj:GetDescendants() return {} end
            function obj:FindFirstChild(name, recursive) return nil end
            function obj:FindFirstAncestor(name) return nil end
            function obj:WaitForChild(name, timeout) return _G.Instance.new("Folder") end
            function obj:IsA(className) return self.ClassName == className end
            function obj:IsDescendantOf(ancestor) return false end
            function obj:GetFullName() return self.Name end
            
            function obj:GetService(serviceName)
                return _G.game:GetService(serviceName)
            end
            
            return obj
        end

        -- RemoteEvent/RemoteFunction (–ø–µ—Ä–µ—Ö–≤–∞—Ç —Å–µ—Ç–µ–≤—ã—Ö –≤—ã–∑–æ–≤–æ–≤)
        local function CreateRemoteEvent(name)
            local obj = _G.Instance.new("RemoteEvent")
            obj.Name = name or "RemoteEvent"
            obj.OnClientEvent = CreateSignal()
            obj.OnServerEvent = CreateSignal()
            
            function obj:FireServer(...)
                local args = {...}
                table.insert(_G.REMOTE_CALLS, {
                    type = "RemoteEvent",
                    name = self.Name,
                    direction = "FireServer",
                    args = args,
                    timestamp = os.time()
                })
                log_action("üì° RemoteEvent:FireServer(" .. self.Name .. ") - " .. #args .. " args")
            end
            
            function obj:FireClient(player, ...)
                log_action("üì° RemoteEvent:FireClient(" .. self.Name .. ")")
            end
            
            function obj:FireAllClients(...)
                log_action("üì° RemoteEvent:FireAllClients(" .. self.Name .. ")")
            end
            
            return obj
        end
        
        local function CreateRemoteFunction(name)
            local obj = _G.Instance.new("RemoteFunction")
            obj.Name = name or "RemoteFunction"
            obj.OnClientInvoke = function() return nil end
            obj.OnServerInvoke = function() return nil end
            
            function obj:InvokeServer(...)
                local args = {...}
                table.insert(_G.REMOTE_CALLS, {
                    type = "RemoteFunction",
                    name = self.Name,
                    direction = "InvokeServer",
                    args = args,
                    timestamp = os.time()
                })
                log_action("üì° RemoteFunction:InvokeServer(" .. self.Name .. ") - " .. #args .. " args")
                return nil
            end
            
            function obj:InvokeClient(player, ...)
                log_action("üì° RemoteFunction:InvokeClient(" .. self.Name .. ")")
                return nil
            end
            
            return obj
        end

        -- Vector3
        _G.Vector3 = {}
        _G.Vector3.__index = _G.Vector3
        function _G.Vector3.new(x, y, z)
            return setmetatable({X = x or 0, Y = y or 0, Z = z or 0}, _G.Vector3)
        end
        _G.Vector3.zero = _G.Vector3.new(0, 0, 0)
        _G.Vector3.one = _G.Vector3.new(1, 1, 1)
        function _G.Vector3.__add(a, b) return _G.Vector3.new(a.X + b.X, a.Y + b.Y, a.Z + b.Z) end
        function _G.Vector3.__sub(a, b) return _G.Vector3.new(a.X - b.X, a.Y - b.Y, a.Z - b.Z) end
        function _G.Vector3.__mul(a, b)
            if type(b) == "number" then return _G.Vector3.new(a.X * b, a.Y * b, a.Z * b) end
            return _G.Vector3.new(a.X * b.X, a.Y * b.Y, a.Z * b.Z)
        end
        function _G.Vector3.__tostring(self) return self.X .. ", " .. self.Y .. ", " .. self.Z end

        -- CFrame
        _G.CFrame = {}
        _G.CFrame.__index = _G.CFrame
        function _G.CFrame.new(...) return setmetatable({}, _G.CFrame) end
        function _G.CFrame.Angles(...) return _G.CFrame.new() end
        function _G.CFrame.fromEulerAnglesXYZ(...) return _G.CFrame.new() end
        function _G.CFrame.__mul(a, b) return a end
        function _G.CFrame:ToEulerAnglesXYZ() return 0, 0, 0 end

        -- –î—Ä—É–≥–∏–µ —Ç–∏–ø—ã
        _G.UDim2 = {new = function(...) return {} end, fromScale = function(...) return {} end, fromOffset = function(...) return {} end}
        _G.Color3 = {new = function(...) return {} end, fromRGB = function(...) return {} end, fromHSV = function(...) return {} end}
        _G.BrickColor = {new = function(...) return {} end, Random = function() return {} end}
        _G.NumberRange = {new = function(...) return {} end}
        _G.NumberSequence = {new = function(...) return {} end}
        _G.ColorSequence = {new = function(...) return {} end}
        _G.Ray = {new = function(...) return {} end}
        
        -- Enum
        _G.Enum = setmetatable({}, {
            __index = function(t, k)
                return setmetatable({}, {
                    __index = function(t2, k2)
                        return {Value = 0, Name = k2, EnumType = k}
                    end
                })
            end
        })

        -- Task library
        _G.task = {
            wait = function(t) return t or 0 end,
            spawn = function(f, ...) pcall(f, ...) end,
            defer = function(f, ...) pcall(f, ...) end,
            delay = function(t, f, ...) pcall(f, ...) end,
            cancel = function() end,
            synchronize = function() return function() end end,
            desynchronize = function() end
        }
        _G.wait = _G.task.wait
        _G.spawn = _G.task.spawn
        _G.delay = _G.task.delay

        -- Game structure
        _G.game = _G.Instance.new("DataModel")
        _G.game.PlaceId = 123456789
        _G.game.GameId = 987654321
        _G.game.JobId = "test-job-id"
        
        -- Players
        _G.game.Players = _G.Instance.new("Players")
        _G.game.Players.LocalPlayer = _G.Instance.new("Player")
        _G.game.Players.LocalPlayer.Name = "DeobfUser"
        _G.game.Players.LocalPlayer.UserId = 123456
        _G.game.Players.LocalPlayer.Character = _G.Instance.new("Model")
        _G.game.Players.LocalPlayer.Character.Humanoid = _G.Instance.new("Humanoid")
        _G.game.Players.LocalPlayer.PlayerGui = _G.Instance.new("PlayerGui")
        
        function _G.game.Players:GetPlayers() return {_G.game.Players.LocalPlayer} end
        
        -- RunService
        _G.game.RunService = _G.Instance.new("RunService")
        _G.game.RunService.RenderStepped = CreateSignal()
        _G.game.RunService.Heartbeat = CreateSignal()
        _G.game.RunService.Stepped = CreateSignal()
        function _G.game.RunService:IsClient() return true end
        function _G.game.RunService:IsServer() return false end
        function _G.game.RunService:IsStudio() return false end
        
        -- HttpService
        _G.game.HttpService = _G.Instance.new("HttpService")
        function _G.game.HttpService:JSONEncode(t) return "{}" end
        function _G.game.HttpService:JSONDecode(s) return {} end
        function _G.game.HttpService:UrlEncode(s) return s end
        function _G.game.HttpService:GenerateGUID() return "MOCK-GUID-12345" end
        function _G.game.HttpService:GetAsync(url)
            log_action("üåê HttpService:GetAsync(" .. tostring(url) .. ")")
            return "<mock response>"
        end
        function _G.game.HttpService:PostAsync(url, data)
            log_action("üåê HttpService:PostAsync(" .. tostring(url) .. ")")
            return "<mock response>"
        end
        
        -- ReplicatedStorage
        _G.game.ReplicatedStorage = _G.Instance.new("ReplicatedStorage")
        
        -- Workspace
        _G.workspace = _G.Instance.new("Workspace")
        _G.game.Workspace = _G.workspace
        
        -- Script context
        _G.script = _G.Instance.new("LocalScript")
        _G.script.Parent = _G.workspace
        
        -- GetService
        function _G.game:GetService(serviceName)
            if serviceName == "Players" then return _G.game.Players end
            if serviceName == "RunService" then return _G.game.RunService end
            if serviceName == "HttpService" then return _G.game.HttpService end
            if serviceName == "ReplicatedStorage" then return _G.game.ReplicatedStorage end
            if serviceName == "Workspace" then return _G.workspace end
            if serviceName == "Lighting" then return _G.Instance.new("Lighting") end
            if serviceName == "StarterGui" then return _G.Instance.new("StarterGui") end
            if serviceName == "UserInputService" then return _G.Instance.new("UserInputService") end
            if serviceName == "TweenService" then return _G.Instance.new("TweenService") end
            return _G.Instance.new(serviceName)
        end

        -- Exploit environment functions
        _G.getgenv = function() return _G end
        _G.getrenv = function() return _G end
        _G.getreg = function() return {} end
        _G.getgc = function(include_tables) return {} end
        _G.getloadedmodules = function() return {} end
        _G.getconnections = function(signal) return {} end
        _G.getcallingscript = function() return _G.script end
        _G.checkcaller = function() return true end
        _G.islclosure = function(f) return type(f) == "function" end
        _G.iscclosure = function(f) return false end
        _G.newcclosure = function(f) return f end
        _G.hookfunction = function(old, new) return old end
        _G.hookmetamethod = function(obj, method, hook) return function() end end
        _G.getnamecallmethod = function() return "" end
        _G.getcallstacksize = function() return 0 end
        _G.isreadonly = function(t) return false end
        _G.setreadonly = function(t, val) end
        _G.isrbxactive = function() return true end
        _G.getrawmetatable = function(obj) return getmetatable(obj) or {} end
        _G.setrawmetatable = function(obj, mt) return setmetatable(obj, mt) end
        
        -- HttpGet/HttpPost (—É—Å—Ç–∞—Ä–µ–≤—à–∏–µ)
        _G.game.HttpGet = function(self, url)
            log_action("üåê game:HttpGet(" .. tostring(url) .. ")")
            return "<mock html>"
        end
        _G.game.HttpPost = function(self, url, data)
            log_action("üåê game:HttpPost(" .. tostring(url) .. ")")
            return "<mock response>"
        end

        -- ============================================
        -- –§–ò–ù–ê–õ–¨–ù–´–ô –î–ê–ú–ü
        -- ============================================
        function _G.dump_globals()
            local ignore_keys = {
                string = 1, math = 1, table = 1, bit = 1, bit32 = 1, 
                coroutine = 1, debug = 1, io = 1, os = 1, package = 1,
                _G = 1, _VERSION = 1, assert = 1, collectgarbage = 1,
                dofile = 1, error = 1, getmetatable = 1, ipairs = 1,
                load = 1, loadstring = 1, next = 1, pairs = 1, pcall = 1,
                print = 1, rawequal = 1, rawget = 1, rawlen = 1, rawset = 1,
                require = 1, select = 1, setmetatable = 1, tonumber = 1,
                tostring = 1, type = 1, unpack = 1, xpcall = 1, warn = 1,
                Instance = 1, Vector3 = 1, CFrame = 1, UDim2 = 1, Color3 = 1,
                BrickColor = 1, Enum = 1, task = 1, wait = 1, spawn = 1,
                delay = 1, game = 1, workspace = 1, script = 1,
                getgenv = 1, getrenv = 1, getreg = 1, getgc = 1,
                CAPTURED_CHUNKS = 1, DETECTED_STRINGS = 1, REMOTE_CALLS = 1,
                ACTION_LOG = 1, FINAL_GLOBALS = 1, FUNCTION_CALLS = 1,
                DECRYPTED_DATA = 1, dump_globals = 1, log_action = 1,
                capture_string = 1, CreateSignal = 1, CreateRemoteEvent = 1,
                CreateRemoteFunction = 1
            }
            
            for k, v in pairs(_G) do
                if not ignore_keys[k] then
                    local vtype = type(v)
                    if vtype == "string" or vtype == "number" or vtype == "boolean" then
                        local value_str = tostring(v)
                        if #value_str < 200 then
                            table.insert(_G.FINAL_GLOBALS, tostring(k) .. " = " .. value_str)
                        else
                            table.insert(_G.FINAL_GLOBALS, tostring(k) .. " = <long string: " .. #value_str .. " chars>")
                        end
                    elseif vtype == "function" then
                        table.insert(_G.FINAL_GLOBALS, tostring(k) .. " = <function>")
                    elseif vtype == "table" then
                        table.insert(_G.FINAL_GLOBALS, tostring(k) .. " = <table>")
                    end
                end
            end
        end
        """

        try:
            update_status("üå™Ô∏è –ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ä–µ–¥—ã –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è...")
            lua.execute(advanced_env)
            
            update_status("üöÄ –ó–∞–ø—É—Å–∫ —Å–∫—Ä–∏–ø—Ç–∞ —Å –ø–æ–ª–Ω—ã–º –ø–µ—Ä–µ—Ö–≤–∞—Ç–æ–º...")
            
            runner = lua.eval("""
                function(code)
                    local success, err = pcall(function()
                        -- –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–∞–∫ —Å—Ç—Ä–æ–∫—É
                        local func, load_err = load(code, "deobf_script", "t", _G)
                        if not func then
                            log_action("‚ùå Load error: " .. tostring(load_err))
                            error(load_err)
                        end
                        
                        -- –í—ã–ø–æ–ª–Ω—è–µ–º
                        func()
                    end)
                    
                    if not success then
                        log_action("‚ùå Execution error: " .. tostring(err))
                    else
                        log_action("‚úÖ Script executed successfully")
                    end
                    
                    -- –°–æ–±–∏—Ä–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                    pcall(_G.dump_globals)
                    
                    return success
                end
            """)
            
            runner(content)

            # –°–±–æ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            strings_dict = lua.globals().DETECTED_STRINGS
            detected_strings = []
            for s in strings_dict:
                count = strings_dict[s]
                detected_strings.append((s, count))
            
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
            detected_strings.sort(key=lambda x: x[1], reverse=True)
            
            global_dump = list(lua.globals().FINAL_GLOBALS)
            action_log = list(lua.globals().ACTION_LOG)
            remote_calls = lua.globals().REMOTE_CALLS
            chunks = lua.globals().CAPTURED_CHUNKS
            
            # –ò–∑–≤–ª–µ–∫–∞–µ–º RemoteSpy –¥–∞–Ω–Ω—ã–µ
            remote_log = []
            if len(remote_calls) > 0:
                for i in range(1, len(remote_calls) + 1):
                    call = remote_calls[i]
                    remote_log.append({
                        'type': call.type,
                        'name': call.name,
                        'direction': call.direction,
                        'args': list(call.args) if call.args else []
                    })
            
            # –ù–∞—Ö–æ–¥–∏–º —Å–∞–º—ã–π –±–æ–ª—å—à–æ–π —á–∞–Ω–∫ (–≤–µ—Ä–æ—è—Ç–Ω–æ —Ä–∞—Å–ø–∞–∫–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥)
            best_chunk = None
            max_size = 0
            if len(chunks) > 0:
                for i in range(1, len(chunks) + 1):
                    c = chunks[i]
                    if c.type == "string" and c.size > max_size:
                        max_size = c.size
                        best_chunk = c.data
            
            target_code = best_chunk if best_chunk else content
            
            return self._finalize_output(
                target_code, 
                detected_strings, 
                global_dump, 
                action_log,
                remote_log,
                update_status
            )

        except Exception as e:
            logger.error(f"Engine Crash: {e}", exc_info=True)
            return f"-- [CRASH ERROR]: {str(e)}".encode('utf-8')

    def _clean_string(self, s):
        if isinstance(s, bytes):
            try: return s.decode('utf-8', errors='replace')
            except: return str(s)
        return str(s)

    def _finalize_output(self, code_bytes, strings_with_count, globals_dump, logs, remote_calls, callback):
        if callback: callback("üìù –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç—á—ë—Ç–∞...")
        
        final_text = "-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n"
        final_text += "-- ‚ïë       ROBLOX LUAU DEOBFUSCATOR V4 - REPORT          ‚ïë\n"
        final_text += "-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n"
        
        # RemoteSpy —Å–µ–∫—Ü–∏—è
        if remote_calls:
            final_text += "-- ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n"
            final_text += "-- ‚îÇ              üî¥ REMOTE SPY CAPTURES                 ‚îÇ\n"
            final_text += "-- ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n"
            for call in remote_calls[:50]:  # –¢–æ–ø 50 –≤—ã–∑–æ–≤–æ–≤
                final_text += f"-- [{call['type']}] {call['name']}:{call['direction']}\n"
                if call['args']:
                    final_text += f"--   Args: {call['args']}\n"
            final_text += "\n"
        
        # –¢–æ–ø —Å—Ç—Ä–æ–∫ (–ø–æ —á–∞—Å—Ç–æ—Ç–µ)
        if strings_with_count:
            final_text += "-- ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n"
            final_text += "-- ‚îÇ           üìú EXTRACTED STRINGS (TOP 100)            ‚îÇ\n"
            final_text += "-- ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n"
            
            for s, count in strings_with_count[:100]:
                clean = self._clean_string(s).replace('\n', '\\n').replace('\r', '')
                if len(clean) > 100:
                    clean = clean[:100] + "..."
                final_text += f'-- [{count}x] "{clean}"\n'
            final_text += "\n"
        
        # –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        if globals_dump:
            final_text += "-- ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n"
            final_text += "-- ‚îÇ              üåç GLOBAL VARIABLES                    ‚îÇ\n"
            final_text += "-- ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n"
            for g in globals_dump[:50]:
                final_text += f"-- {self._clean_string(g)}\n"
            final_text += "\n"
        
        # –õ–æ–≥–∏ –¥–µ–π—Å—Ç–≤–∏–π
        if logs:
            final_text += "-- ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n"
            final_text += "-- ‚îÇ                üìä EXECUTION LOG                     ‚îÇ\n"
            final_text += "-- ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n"
            for l in logs[-30:]:
                final_text += f"-- {self._clean_string(l)}\n"
            final_text += "\n"
        
        # –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–¥
        final_text += "-- ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n"
        final_text += "-- ‚ïë                  üíé MAIN SOURCE CODE                 ‚ïë\n"
        final_text += "-- ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n"
        
        try:
            if isinstance(code_bytes, bytes):
                source = code_bytes.decode('utf-8', errors='replace')
            else:
                source = str(code_bytes)
            
            final_text += self._beautify_lua(source)
        except Exception as e:
            final_text += f"-- [ERROR decoding source]: {e}\n"
            final_text += f"-- Hex dump: {binascii.hexlify(code_bytes[:500])}\n"
        
        return final_text.encode('utf-8')

    def _beautify_lua(self, source_code):
        """–ë–∞–∑–æ–≤–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ Lua –∫–æ–¥–∞"""
        # –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–Ω–æ—Å—ã —Å—Ç—Ä–æ–∫ –ø–æ—Å–ª–µ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
        keywords = ['then', 'do', 'repeat', 'else', 'elseif']
        for kw in keywords:
            source_code = re.sub(rf'\s+{kw}\s+', f' {kw}\n', source_code)
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º end
        source_code = re.sub(r'\s+end\s+', '\nend\n', source_code)
        
        # –¢–æ—á–∫–∞ —Å –∑–∞–ø—è—Ç–æ–π
        source_code = source_code.replace(';', ';\n')
        
        return source_code

import asyncio
import os
import logging
import uuid
from aiogram import Bot, Dispatcher, F, types
from aiogram.types import FSInputFile
from aiogram.filters import Command

from engine import DeobfuscatorEngine

API_TOKEN = '–¢–í–û–ô_–¢–û–ö–ï–ù_–°–Æ–î–ê'

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(name)s - %(message)s")
logger = logging.getLogger("DeobfBot")

bot = Bot(token=API_TOKEN)
dp = Dispatcher()
engine = DeobfuscatorEngine()

@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    await message.answer(
        "ü§ñ **Roblox Luau Deobfuscator V4**\n\n"
        "üî• **–ù–æ–≤–æ–µ:**\n"
        "‚Ä¢ –ü–æ–ª–Ω–∞—è —ç–º—É–ª—è—Ü–∏—è Luau –æ–∫—Ä—É–∂–µ–Ω–∏—è\n"
        "‚Ä¢ RemoteSpy (–ø–µ—Ä–µ—Ö–≤–∞—Ç —Å–µ—Ç–µ–≤—ã—Ö –≤—ã–∑–æ–≤–æ–≤)\n"
        "‚Ä¢ –ì–ª—É–±–æ–∫–∏–π –ø–µ—Ä–µ—Ö–≤–∞—Ç string –æ–ø–µ—Ä–∞—Ü–∏–π\n"
        "‚Ä¢ –¢—Ä–µ–∫–∏–Ω–≥ load/loadstring –≤—ã–∑–æ–≤–æ–≤\n"
        "‚Ä¢ –ß–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å—Ç—Ä–æ–∫\n\n"
        "üì§ –û—Ç–ø—Ä–∞–≤—å `.lua` –∏–ª–∏ `.txt` —Ñ–∞–π–ª\n"
        "‚ö° –ü–æ–¥–¥–µ—Ä–∂–∫–∞: MoonSec, IronBrew, Luraph, PSU",
        parse_mode="Markdown"
    )

@dp.message(F.document)
async def handle_document(message: types.Message):
    user_id = message.from_user.id
    unique_id = uuid.uuid4().hex[:8]
    file_name = message.document.file_name or "script.lua"
    
    input_path = f"temp_{user_id}_{unique_id}.lua"
    output_path = f"Deobf_{unique_id}_{file_name}.txt"

    status_msg = await message.answer("‚è≥ **–ó–∞–≥—Ä—É–∑–∫–∞...**", parse_mode="Markdown")
    loop = asyncio.get_running_loop()
    last_status = [""]
    
    def sync_status_updater(text):
        if text == last_status[0]: return
        last_status[0] = text
        
        async def edit_coro():
            try:
                await status_msg.edit_text(f"‚öôÔ∏è {text}", parse_mode="Markdown")
            except: pass
        
        if not loop.is_closed():
            asyncio.run_coroutine_threadsafe(edit_coro(), loop)

    try:
        file = await bot.get_file(message.document.file_id)
        await bot.download_file(file.file_path, input_path)

        with open(input_path, "rb") as f: content = f.read()

        result_data = await asyncio.wait_for(
            loop.run_in_executor(None, engine.process, content, sync_status_updater),
            timeout=180.0
        )

        with open(output_path, "wb") as f: f.write(result_data)
        out_file = FSInputFile(output_path)
        
        caption = "‚úÖ **–î–µ–æ–±—Ñ—É—Å–∫–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!**\n"
        
        result_str = result_data.decode('utf-8', errors='ignore')
        if "REMOTE SPY CAPTURES" in result_str:
            caption += "üì° RemoteSpy: –ü–µ—Ä–µ—Ö–≤–∞—á–µ–Ω—ã –≤—ã–∑–æ–≤—ã\n"
        if "EXTRACTED STRINGS" in result_str:
            caption += "üìú –ò–∑–≤–ª–µ—á–µ–Ω—ã —Å–∫—Ä—ã—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏\n"
        if "GLOBAL VARIABLES" in result_str:
            caption += "üåç –ù–∞–π–¥–µ–Ω—ã –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ\n"
        
        await message.answer_document(out_file, caption=caption, parse_mode="Markdown")

    except asyncio.TimeoutError:
        await status_msg.edit_text("‚ùå **–¢–∞–π–º-–∞—É—Ç** (>3 –º–∏–Ω). –°–∫—Ä–∏–ø—Ç —Å–ª–∏—à–∫–æ–º —Å–ª–æ–∂–Ω—ã–π.")
    except Exception as e:
        logger.error(f"Error: {e}", exc_info=True)
        await status_msg.edit_text(f"‚ùå –û—à–∏–±–∫–∞: {str(e)[:100]}")
    finally:
        for p in [input_path, output_path]:
            if os.path.exists(p):
                try: os.remove(p)
                except: pass

async def main():
    logger.info("üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    await bot.delete_webhook(drop_pending_updates=True)
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        if os.name == 'nt':
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nüëã –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
