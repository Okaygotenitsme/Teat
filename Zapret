import lupa
from lupa import LuaRuntime
import logging
import subprocess
import os
import tempfile
import re
import binascii
import requests
import time

# –õ–æ–≥–≥–µ—Ä
logger = logging.getLogger("DeobfuscatorEngine")

class DeobfuscatorEngine:
    def __init__(self):
        base_dir = os.path.dirname(os.path.abspath(__file__))
        self.unluac_path = os.path.join(base_dir, "unluac.jar")
        logger.info(f"üìÅ Working Dir: {base_dir}")

    def process(self, content, status_callback=None):
        def update_status(msg):
            if status_callback: status_callback(msg)
            logger.info(f"[STATUS] {msg}")

        if not self._check_java():
            return b"-- [FATAL] Java is missing. Install Java to use unluac."

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ Luau Bytecode (–ø–æ–¥–ø–∏—Å—å 0x00 + –≤–µ—Ä—Å–∏—è –∏–ª–∏ "LuaQ")
        is_luau = False
        if content.startswith(b'\x1bLua') and len(content) > 4 and content[4] >= 0x04:
            update_status("‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω Luau Bytecode (Binary). –î–µ–∫–æ–º–ø–∏–ª—è—Ü–∏—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∞.")
            is_luau = True

        update_status("üß† –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ä–µ–¥—ã Roblox (God Mode V3)...")

        # --- –ù–ê–°–¢–†–û–ô–ö–ê LUA VM ---
        try:
            lua = LuaRuntime(unpack_returned_tuples=True, encoding=None)
        except Exception as e:
            return f"-- [FATAL] Lua start error: {e}".encode('utf-8')

        # [NETWORK BRIDGE]
        def py_http_get(url):
            try:
                url = str(url).strip()
                headers = {"User-Agent": "Roblox/WinInet", "Accept": "text/plain"}
                update_status(f"üåê GET Request: {url[:60]}...")
                response = requests.get(url, headers=headers, timeout=5)
                if response.status_code == 200:
                    return response.text
                return ""
            except Exception as e:
                logger.error(f"Network Error: {e}")
                return ""

        lua.globals().PYTHON_HTTP_GET = py_http_get

        # ==========================================
        # 1. LUA SCRIPT: ADVANCED EMULATION
        # ==========================================
        lua_env_setup = """
        -- :: LOGGING CONTAINERS ::
        _G.CAPTURED_STRINGS = {}
        _G.RECONSTRUCTED_CODE = {}  -- –°—é–¥–∞ –ø–∏—à–µ–º –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π –∫–æ–¥
        _G.GLOBALS_DUMP = {}

        local function log_code(line)
            if #_G.RECONSTRUCTED_CODE < 2000 then 
                table.insert(_G.RECONSTRUCTED_CODE, line) 
            end
        end

        local function log_string(s)
            if type(s) == "string" and #s > 3 then
                _G.CAPTURED_STRINGS[s] = true
            end
        end

        -- :: POLYFILLS (Bitwise) ::
        local bit = {}
        function bit.tobit(x) x = x % 4294967296; if x >= 2147483648 then x = x - 4294967296 end; return x end
        function bit.bnot(x) return 4294967295 - x % 4294967296 end
        local function bit_oper(a, b, oper)
            local r, m, s = 0, 2^31, nil
            repeat s,a,b = a+b+m, a%m, b%m; r,m = r + m*oper%(s-a-b), m/2 until m < 1
            return r
        end
        function bit.band(a, b) return bit_oper(a, b, 4) end
        function bit.bor(a, b)  return bit_oper(a, b, 1) end
        function bit.bxor(a, b) return bit_oper(a, b, 3) end
        function bit.lshift(a, b) return (a * 2^b) % 4294967296 end
        function bit.rshift(a, b) return math.floor(a / 2^b) % 4294967296 end
        package.loaded.bit = bit; _G.bit = bit; _G.bit32 = bit

        -- :: ANTI-DETECTION & DEBUG API ::
        _G.debug = {}
        _G.debug.getinfo = function(...) return {source="=[C]", what="C", name="debug", short_src="[C]"} end
        _G.debug.traceback = function(...) return "Stack Traceback" end
        _G.debug.getupvalue = function(...) return nil end
        _G.debug.getconstants = function(...) return {} end
        
        _G.os.clock = function() return 0.1 end
        _G.os.time = function() return 100000 end
        _G.tick = function() return 100000 end

        _G.task = { 
            wait = function(t) return t or 0 end, 
            spawn = function(f) pcall(f) end, 
            delay = function(t,f) pcall(f) end,
            defer = function(f) pcall(f) end
        }
        _G.wait = _G.task.wait
        _G.spawn = _G.task.spawn

        -- :: ROBLOX INSTANCE MOCK (THE SPY) ::
        local InstanceMT = {
            __index = function(self, key)
                -- –í–æ–∑–≤—Ä–∞—Ç –º–µ—Ç–æ–¥–∞, –∫–æ—Ç–æ—Ä—ã–π –ª–æ–≥–∏—Ä—É–µ—Ç –≤—ã–∑–æ–≤
                return function(self_dummy, ...)
                    local args = {...}
                    local arg_str = ""
                    for i,v in ipairs(args) do 
                        if type(v)=="string" then arg_str = arg_str .. '"'..v..'", ' 
                        else arg_str = arg_str .. tostring(v) .. ", " end
                    end
                    arg_str = arg_str:sub(1, -3) -- remove comma
                    
                    -- –õ–æ–≥–∏—Ä—É–µ–º –¥–µ–π—Å—Ç–≤–∏–µ –∫–∞–∫ –∫–æ–¥
                    log_code("game." .. self.Name .. ":" .. key .. "(" .. arg_str .. ")")
                    
                    if key == "GetService" then
                        local srv = args[1]
                        if not _G.game[srv] then
                            _G.game[srv] = _G.Instance.new(srv, _G.game)
                        end
                        return _G.game[srv]
                    elseif key == "HttpGet" or key == "HttpGetAsync" then
                         -- –†–µ–∞–ª—å–Ω—ã–π –∑–∞–ø—Ä–æ—Å —á–µ—Ä–µ–∑ Python
                         log_string(args[1])
                         local res = PYTHON_HTTP_GET(args[1])
                         if #res > 50 then 
                            log_code("-- [DOWNLOADED] " .. #res .. " bytes") 
                         end
                         return res
                    end
                    
                    return _G.Instance.new("Folder") -- –ó–∞–≥–ª—É—à–∫–∞
                end
            end,
            __newindex = function(self, key, value)
                log_code(self.Name .. "." .. key .. " = " .. tostring(value))
                rawset(self, key, value)
            end,
            __tostring = function(self) return self.Name end
        }

        _G.Instance = {}
        function _G.Instance.new(className, parent)
            local obj = {Name = className or "Object", ClassName = className or "Object", Parent = parent}
            -- Special handling
            if className == "Player" then obj.UserId = 123456 end
            
            -- –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –º–µ—Ç–∞—Ç–∞–±–ª–∏—Ü—É —à–ø–∏–æ–Ω–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤, –Ω–µ —Ñ—É–Ω–∫—Ü–∏–π)
            -- –í Lupa —Å–ª–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å __namecall, –ø–æ—ç—Ç–æ–º—É –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–º—ã–∫–∞–Ω–∏—è –≤ __index
            local proxy = {}
            local meta = {
                __index = function(t, k)
                    if obj[k] then return obj[k] end
                    -- –ú–∞–≥–∏—è –ø–µ—Ä–µ—Ö–≤–∞—Ç–∞ –º–µ—Ç–æ–¥–æ–≤
                    return function(_, ...)
                         local args = {...}
                         local arg_str = ""
                         for i,v in ipairs(args) do 
                             if type(v)=="string" then arg_str = arg_str .. '"'..v..'"' 
                             else arg_str = arg_str .. tostring(v) end
                             if i < #args then arg_str = arg_str .. ", " end
                         end
                         log_code(obj.Name .. ":" .. k .. "(" .. arg_str .. ")")
                         
                         if k == "HttpGet" then return PYTHON_HTTP_GET(args[1]) end
                         return _G.Instance.new("Folder")
                    end
                end,
                __newindex = function(t, k, v)
                    log_code(obj.Name .. "." .. k .. " = " .. tostring(v))
                    obj[k] = v
                end,
                __tostring = function(t) return obj.Name end
            }
            return setmetatable(proxy, meta)
        end

        -- :: GAME ROOT ::
        _G.game = _G.Instance.new("DataModel")
        _G.game.Name = "game"
        _G.workspace = _G.Instance.new("Workspace", _G.game)
        _G.game.Players = _G.Instance.new("Players", _G.game)
        _G.game.Players.LocalPlayer = _G.Instance.new("Player", _G.game.Players)
        _G.game.Players.LocalPlayer.Name = "LocalPlayer"
        
        -- :: EXPLOIT ENVIRONMENT ::
        _G.identifyexecutor = function() return "Synapse X" end
        _G.getgenv = function() return _G end
        _G.request = function(opt) 
             log_code("request({Url='"..tostring(opt.Url).."'})")
             return {Body=PYTHON_HTTP_GET(opt.Url), StatusCode=200} 
        end
        _G.syn = { request = _G.request }

        -- :: STRING HOOKS ::
        local old_char = string.char
        string.char = function(...)
            local res = old_char(...)
            if #res > 4 then log_string(res) end
            return res
        end
        
        -- :: GLOBAL DUMPER ::
        function _G.dump_all()
             for k,v in pairs(_G) do
                if type(v) == "string" or type(v) == "number" then
                    table.insert(_G.GLOBALS_DUMP, k.." = "..tostring(v))
                end
             end
        end
        """

        try:
            update_status("üå™Ô∏è –ó–∞–ø—É—Å–∫ —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏ (Tracing)...")
            
            lua.execute(lua_env_setup)
            
            # Runner —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –æ—à–∏–±–æ–∫
            runner = lua.eval("""
                function(code)
                    local status, err = pcall(function()
                        local f = load(code)
                        if not f then error("Cannot load chunk") end
                        f()
                    end)
                    if not status then
                        table.insert(_G.RECONSTRUCTED_CODE, "-- [ERROR] Script crash: " .. tostring(err))
                    end
                    pcall(_G.dump_all)
                    return true
                end
            """)
            
            runner(content)

            # –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö
            captured_strings = []
            tbl = lua.globals().CAPTURED_STRINGS
            if tbl:
                for k in tbl: captured_strings.append(str(k))
            
            reconstructed_code = []
            code_tbl = lua.globals().RECONSTRUCTED_CODE
            if code_tbl:
                for k in code_tbl.values(): reconstructed_code.append(str(k))
                
            return self._finalize_output(content, captured_strings, reconstructed_code, is_luau, update_status)

        except Exception as e:
            logger.error(f"Engine Crash: {e}")
            return f"-- [CRASH ERROR]: {str(e)}".encode('utf-8')

    def _check_java(self):
        try:
            subprocess.run(["java", "-version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return True
        except: return False

    def _clean_string(self, text):
        """
        –£–º–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –º—É—Å–æ—Ä–∞. –û—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ —á–∏—Ç–∞–µ–º—ã–µ —Å—Ç—Ä–æ–∫–∏, URL –∏ AssetID.
        """
        if isinstance(text, bytes):
            try: text = text.decode('utf-8', 'ignore')
            except: return ""
            
        # –£–±–∏—Ä–∞–µ–º –≤—Å–µ —Å–∏–º–≤–æ–ª—ã, –∫—Ä–æ–º–µ –ø–µ—á–∞—Ç–Ω—ã—Ö ASCII –∏ —Ä—É—Å—Å–∫–∏—Ö –±—É–∫–≤
        # –û—Å—Ç–∞–≤–ª—è–µ–º —Å–∏–º–≤–æ–ª—ã: a-zA-Z0-9, —Ä—É—Å—Å–∫–∏–µ, –∑–Ω–∞–∫–∏ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è
        # –ü–∞—Ç—Ç–µ—Ä–Ω: –ù–∞–π—Ç–∏ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ > 4 —Å–∏–º–≤–æ–ª–æ–≤
        clean_text = ""
        
        # 1. –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º URL –∏ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
        urls = re.findall(r'(https?://[^\s<>"]+|rbxassetid://\d+)', text)
        
        # 2. –ò—â–µ–º –ø—Ä–æ—Å—Ç–æ —Å–ª–æ–≤–∞/–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
        # –ü–∞—Ç—Ç–µ—Ä–Ω: –±—É–∫–≤—ã/—Ü–∏—Ñ—Ä—ã, –¥–ª–∏–Ω–∞ –æ—Ç 4 –¥–æ 100
        words = re.findall(r'([a-zA-Z0-9_\-\.\/:\s]{4,100})', text)
        
        valid_items = set(urls)
        for w in words:
            w = w.strip()
            # –§–∏–ª—å—Ç—Ä —Å–æ–≤—Å–µ–º –º—É—Å–æ—Ä–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä "x00x05")
            if len(w) > 3 and not re.search(r'[\x00-\x1f]', w):
                valid_items.add(w)

        return sorted(list(valid_items), key=len, reverse=True)

    def _finalize_output(self, original_bytes, strings, reconstructed_log, is_luau, callback):
        if callback: callback("üß¨ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –æ—Ç—á–µ—Ç–∞...")
        
        final_text = "-- [[ DEOBFUSCATOR V3 (GOD MODE) REPORT ]] --\n"
        final_text += f"-- Date: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        
        # 1. –í–´–í–û–î –°–¢–†–û–ö (–û—á–∏—â–µ–Ω–Ω—ã–π)
        final_text += "-- [[ üîé DETECTED STRINGS / URLS ]] --\n"
        # –°–æ–±–∏—Ä–∞–µ–º —Å—Ç—Ä–æ–∫–∏ –∏–∑ –ª–æ–≥–∞ + —Å—Ç—Ä–æ–∫–∏ –∏–∑ –±–∞–π—Ç–∫–æ–¥–∞ (—á–µ—Ä–µ–∑ —Ä–µ–≥—É–ª—è—Ä–∫–∏)
        raw_strings = self._clean_string(original_bytes)
        combined_strings = set(self._clean_string('\n'.join(strings)) + raw_strings)
        
        for s in combined_strings:
            final_text += f'-- "{s}"\n'
            
        # 2. –†–ï–ö–û–ù–°–¢–†–£–ò–†–û–í–ê–ù–ù–´–ô –ö–û–î (–°–∞–º–æ–µ —Ü–µ–Ω–Ω–æ–µ)
        final_text += "\n" + "="*40 + "\n-- [[ üõ† RECONSTRUCTED LOGIC ]] --\n"
        final_text += "-- –≠—Ç–æ—Ç –∫–æ–¥ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç, —á—Ç–æ —Å–∫—Ä–∏–ø—Ç –¥–µ–ª–∞–ª –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.\n\n"
        
        if reconstructed_log:
            for line in reconstructed_log:
                final_text += f"{line}\n"
        else:
            final_text += "-- [INFO] –õ–æ–≥ –¥–µ–π—Å—Ç–≤–∏–π –ø—É—Å—Ç (—Å–∫—Ä–∏–ø—Ç –Ω–µ –≤—ã–ø–æ–ª–Ω–∏–ª –∞–∫—Ç–∏–≤–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –∏–ª–∏ —É–ø–∞–ª —Å—Ä–∞–∑—É).\n"

        # 3. –î–ï–ö–û–ú–ü–ò–õ–Ø–¶–ò–Ø
        final_text += "\n" + "="*40 + "\n-- [[ üìú SOURCE DECOMPILATION ]] --\n"
        
        if is_luau:
            final_text += "-- [WARNING] –û–±–Ω–∞—Ä—É–∂–µ–Ω Luau Bytecode. Unluac –Ω–µ –º–æ–∂–µ—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–¥.\n"
            final_text += "-- –ù–∏–∂–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω —Å—ã—Ä–æ–π –¥–∞–º–ø (–ø–æ–ø—Ä–æ–±—É–π—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Node.js –¥–µ–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—ã –¥–ª—è Luau).\n\n"
            try: final_text += original_bytes.decode('utf-8', 'ignore')[:2000] # –û–≥—Ä–∞–Ω–∏—á–∏–º –≤—ã–≤–æ–¥
            except: pass
        else:
            decompiled = self._try_decompile(original_bytes)
            if decompiled:
                try: src = decompiled.decode('utf-8', 'ignore')
                except: src = decompiled.decode('latin-1', 'ignore')
                final_text += self._beautify_lua(src)
            else:
                final_text += "-- [WARNING] Decompilation skipped or failed.\n"

        return final_text.encode('utf-8')

    def _try_decompile(self, bytecode):
        # –ï—Å–ª–∏ —ç—Ç–æ –ø—Ä–æ—Å—Ç–æ–π —Ç–µ–∫—Å—Ç, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º
        if bytecode.strip().startswith(b"--") or b"local " in bytecode:
            return bytecode

        if not os.path.exists(self.unluac_path): return None
        try:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".lua", mode='wb') as tmp:
                tmp.write(bytecode)
                path = tmp.name
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º unluac
            res = subprocess.run(
                ["java", "-Xmx1G", "-jar", self.unluac_path, path], 
                capture_output=True, timeout=15
            )
            os.remove(path)
            if res.returncode == 0 and len(res.stdout) > 0: return res.stdout
            return None
        except: return None

    def _beautify_lua(self, source_code):
        # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –∫—Ä–∞—Å–æ—Ç—ã
        source_code = re.sub(r'(\s)(local|return|if|for|while|repeat|function)(\s)', r'\n\2 ', source_code)
        return source_code
