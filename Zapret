import lupa
from lupa import LuaRuntime
import logging
import os
import re
import binascii

logger = logging.getLogger("DeobfuscatorEngine")

class DeobfuscatorEngine:
    def __init__(self):
        base_dir = os.path.dirname(os.path.abspath(__file__))
        logger.info(f"ğŸ“ Working Dir: {base_dir}")

    def process(self, content, status_callback=None):
        def update_status(msg):
            if status_callback: status_callback(msg)
            logger.info(f"[STATUS] {msg}")

        update_status("ğŸ§  Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ğ¾Ğ¹ ÑÑ€ĞµĞ´Ñ‹ Luau (Emulation V4)...")

        try:
            lua = LuaRuntime(unpack_returned_tuples=True, encoding=None)
        except Exception as e:
            return f"-- [FATAL] Lua start error: {e}".encode('utf-8')

        # ==========================================
        # Ğ ĞĞ¡Ğ¨Ğ˜Ğ Ğ•ĞĞĞĞ¯ Ğ­ĞœĞ£Ğ›Ğ¯Ğ¦Ğ˜Ğ¯ Ğ¡ Ğ“Ğ›Ğ£Ğ‘ĞĞšĞ˜Ğœ ĞŸĞ•Ğ Ğ•Ğ¥Ğ’ĞĞ¢ĞĞœ
        # ==========================================
        
        advanced_env = """
        -- ============================================
        -- Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ ĞŸĞ•Ğ Ğ•Ğ¥Ğ’ĞĞ¢Ğ (Ğ¢Ğ Ğ•ĞšĞ˜ĞĞ“) - Ğ˜ĞĞ˜Ğ¦Ğ˜ĞĞ›Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯ ĞŸĞ•Ğ Ğ’ĞĞ™!
        -- ============================================
        _G.CAPTURED_CHUNKS = {}
        _G.DETECTED_STRINGS = {}
        _G.REMOTE_CALLS = {}
        _G.ACTION_LOG = {}
        _G.FINAL_GLOBALS = {}
        _G.FUNCTION_CALLS = {}
        _G.DECRYPTED_DATA = {}
        
        local function log_action(msg)
            if #_G.ACTION_LOG < 1000 then
                table.insert(_G.ACTION_LOG, tostring(msg))
            end
        end

        local function capture_string(s)
            if type(s) == "string" and #s > 2 and #s < 10000 then
                -- Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ Ñ‚ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Lua VM
                local skip = {
                    "stack begin", "upvalue", "function", "table", "userdata",
                    "thread", "proto", "light userdata", "nil"
                }
                local should_skip = false
                for _, pattern in ipairs(skip) do
                    if s:find(pattern, 1, true) then
                        should_skip = true
                        break
                    end
                end
                
                if not should_skip then
                    _G.DETECTED_STRINGS[s] = (_G.DETECTED_STRINGS[s] or 0) + 1
                end
            end
            return s
        end

        -- ============================================
        -- BITWISE OPERATIONS (ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ğ¾ Ğ´Ğ»Ñ Ğ¾Ğ±Ñ„ÑƒÑĞºĞ°Ñ†Ğ¸Ğ¸)
        -- ============================================
        local bit = {}
        function bit.tobit(x) 
            x = x % 4294967296
            if x >= 2147483648 then x = x - 4294967296 end
            return x 
        end
        function bit.bnot(x) return (-1 - x) % 4294967296 end
        function bit.tohex(x, n)
            n = n or 8
            local up
            if n <= 0 then
                if n == 0 then return '' end
                up = true
                n = - n
            end
            x = bit.band(x, 16^n-1)
            return ('%0'..n..(up and 'X' or 'x')):format(x)
        end
        
        local function bit_oper(a, b, oper)
            local r, m = 0, 2^31
            repeat
                local aa, bb = a % m, b % m
                r = r + m * oper % (aa + bb - aa * bb / m)
                a, b, m = (a - aa) / 2, (b - bb) / 2, m / 2
            until m < 1
            return r
        end
        
        function bit.band(a, b) return bit_oper(a, b, 1) end
        function bit.bor(a, b) return bit_oper(a, b, 7) end
        function bit.bxor(a, b) return bit_oper(a, b, 6) end
        function bit.lshift(a, n) return (a * 2^n) % 4294967296 end
        function bit.rshift(a, n) return math.floor(a / 2^n) % 4294967296 end
        function bit.arshift(a, n)
            if a >= 2147483648 then
                a = a - 4294967296
            end
            return math.floor(a / 2^n)
        end
        function bit.rol(x, n) return bit.lshift(x, n) + bit.rshift(x, 32 - n) end
        function bit.ror(x, n) return bit.rshift(x, n) + bit.lshift(x, 32 - n) end
        
        package.loaded.bit = bit
        package.loaded.bit32 = bit
        _G.bit = bit
        _G.bit32 = bit

        -- ============================================
        -- ĞŸĞ•Ğ Ğ•Ğ¥Ğ’ĞĞ¢ STRING ĞĞŸĞ•Ğ ĞĞ¦Ğ˜Ğ™
        -- ============================================
        local string_mt = getmetatable("")
        local real_string = {}
        
        -- Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¾Ñ€Ğ¸Ğ³Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
        for k, v in pairs(string) do
            real_string[k] = v
        end
        
        -- Ğ¥ÑƒĞº string.char (ÑĞ°Ğ¼Ğ¾Ğµ Ñ‡Ğ°ÑÑ‚Ğ¾Ğµ Ğ² Ğ´ĞµĞ¾Ğ±Ñ„ÑƒÑĞºĞ°Ñ†Ğ¸Ğ¸)
        string.char = function(...)
            local args = {...}
            local result = real_string.char(...)
            
            -- Ğ›Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ·Ğ½Ğ°Ñ‡Ğ¸Ğ¼Ñ‹Ğµ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ñ‹
            if #args > 1 then
                capture_string(result)
                if #result < 50 then
                    log_action("ğŸ”¡ string.char(" .. #args .. " bytes) -> [" .. #result .. " chars]")
                else
                    log_action("ğŸ”¡ string.char(" .. #args .. " bytes) -> " .. #result .. " chars")
                end
            end
            
            return result
        end
        
        -- Ğ¥ÑƒĞº string.byte
        string.byte = function(s, i, j)
            capture_string(s)
            return real_string.byte(s, i, j)
        end
        
        -- Ğ¥ÑƒĞº string.sub
        string.sub = function(s, i, j)
            local result = real_string.sub(s, i, j)
            if #result > 10 then
                capture_string(result)
            end
            return result
        end
        
        -- Ğ¥ÑƒĞº string.gsub
        string.gsub = function(s, pattern, repl, n)
            local result, count = real_string.gsub(s, pattern, repl, n)
            if count > 0 and #result > 10 then
                capture_string(result)
                log_action("ğŸ”„ gsub: " .. count .. " replacements")
            end
            return result, count
        end
        
        -- Ğ¥ÑƒĞº table.concat
        local real_concat = table.concat
        table.concat = function(t, sep, i, j)
            local result = real_concat(t, sep, i, j)
            if type(result) == "string" and #result > 10 then
                capture_string(result)
            end
            return result
        end

        -- ============================================
        -- ĞŸĞ•Ğ Ğ•Ğ¥Ğ’ĞĞ¢ Ğ—ĞĞ“Ğ Ğ£Ğ—ĞšĞ˜ ĞšĞĞ”Ğ
        -- ============================================
        local real_load = load or loadstring
        local load_count = 0
        
        local function hooked_load(chunk, chunkname, mode, env)
            load_count = load_count + 1
            
            if type(chunk) == "string" then
                local size = #chunk
                
                -- Ğ—Ğ°Ñ…Ğ²Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ²ÑĞµ Ñ‡Ğ°Ğ½ĞºĞ¸ > 100 Ğ±Ğ°Ğ¹Ñ‚
                if size > 100 then
                    table.insert(_G.CAPTURED_CHUNKS, {
                        data = chunk,
                        size = size,
                        name = chunkname or ("chunk_" .. load_count),
                        type = "string"
                    })
                    log_action("ğŸ”¥ Captured chunk #" .. load_count .. ": " .. size .. " bytes")
                    capture_string(chunk)
                end
            elseif type(chunk) == "function" then
                log_action("ğŸ”¥ load() called with function (bytecode loader)")
                table.insert(_G.CAPTURED_CHUNKS, {
                    data = "<function>",
                    size = 0,
                    name = chunkname or ("func_chunk_" .. load_count),
                    type = "function"
                })
            end
            
            return real_load(chunk, chunkname, mode, env)
        end
        
        load = hooked_load
        loadstring = hooked_load
        _G.load = hooked_load
        _G.loadstring = hooked_load

        -- ============================================
        -- Ğ ĞĞ¡Ğ¨Ğ˜Ğ Ğ•ĞĞĞĞ¯ ROBLOX API
        -- ============================================
        
        -- Signal (ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ)
        local function CreateSignal()
            local sig = {}
            local connections = {}
            
            function sig:Connect(callback)
                local conn = {
                    Connected = true,
                    Disconnect = function(self)
                        self.Connected = false
                        for i, c in ipairs(connections) do
                            if c == conn then
                                table.remove(connections, i)
                                break
                            end
                        end
                    end
                }
                table.insert(connections, {callback = callback, conn = conn})
                return conn
            end
            
            function sig:Fire(...)
                for _, data in ipairs(connections) do
                    if data.conn.Connected then
                        pcall(data.callback, ...)
                    end
                end
            end
            
            function sig:Wait()
                coroutine.yield()
                return nil
            end
            
            return sig
        end

        -- Instance (Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ ĞºĞ»Ğ°ÑÑ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ¾Ğ²)
        _G.Instance = {}
        _G.Instance.__index = _G.Instance
        
        function _G.Instance.new(className, parent)
            local obj = setmetatable({}, _G.Instance)
            obj.ClassName = className or "Part"
            obj.Name = className or "Instance"
            obj.Parent = parent
            obj.Archivable = true
            obj.Changed = CreateSignal()
            obj.ChildAdded = CreateSignal()
            obj.ChildRemoved = CreateSignal()
            obj.AncestryChanged = CreateSignal()
            obj.Destroying = CreateSignal()
            
            function obj:Destroy()
                self.Destroying:Fire()
                self.Parent = nil
            end
            
            function obj:Clone()
                return _G.Instance.new(self.ClassName, self.Parent)
            end
            
            function obj:ClearAllChildren() end
            function obj:GetChildren() return {} end
            function obj:GetDescendants() return {} end
            function obj:FindFirstChild(name, recursive) return nil end
            function obj:FindFirstAncestor(name) return nil end
            function obj:WaitForChild(name, timeout) return _G.Instance.new("Folder") end
            function obj:IsA(className) return self.ClassName == className end
            function obj:IsDescendantOf(ancestor) return false end
            function obj:GetFullName() return self.Name end
            
            function obj:GetService(serviceName)
                return _G.game:GetService(serviceName)
            end
            
            return obj
        end

        -- RemoteEvent/RemoteFunction (Ğ¿ĞµÑ€ĞµÑ…Ğ²Ğ°Ñ‚ ÑĞµÑ‚ĞµĞ²Ñ‹Ñ… Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ²)
        local function CreateRemoteEvent(name)
            local obj = _G.Instance.new("RemoteEvent")
            obj.Name = name or "RemoteEvent"
            obj.OnClientEvent = CreateSignal()
            obj.OnServerEvent = CreateSignal()
            
            function obj:FireServer(...)
                local args = {...}
                table.insert(_G.REMOTE_CALLS, {
                    type = "RemoteEvent",
                    name = self.Name,
                    direction = "FireServer",
                    args = args,
                    timestamp = os.time()
                })
                log_action("ğŸ“¡ RemoteEvent:FireServer(" .. self.Name .. ") - " .. #args .. " args")
            end
            
            function obj:FireClient(player, ...)
                log_action("ğŸ“¡ RemoteEvent:FireClient(" .. self.Name .. ")")
            end
            
            function obj:FireAllClients(...)
                log_action("ğŸ“¡ RemoteEvent:FireAllClients(" .. self.Name .. ")")
            end
            
            return obj
        end
        
        local function CreateRemoteFunction(name)
            local obj = _G.Instance.new("RemoteFunction")
            obj.Name = name or "RemoteFunction"
            obj.OnClientInvoke = function() return nil end
            obj.OnServerInvoke = function() return nil end
            
            function obj:InvokeServer(...)
                local args = {...}
                table.insert(_G.REMOTE_CALLS, {
                    type = "RemoteFunction",
                    name = self.Name,
                    direction = "InvokeServer",
                    args = args,
                    timestamp = os.time()
                })
                log_action("ğŸ“¡ RemoteFunction:InvokeServer(" .. self.Name .. ") - " .. #args .. " args")
                return nil
            end
            
            function obj:InvokeClient(player, ...)
                log_action("ğŸ“¡ RemoteFunction:InvokeClient(" .. self.Name .. ")")
                return nil
            end
            
            return obj
        end

        -- Vector3
        _G.Vector3 = {}
        _G.Vector3.__index = _G.Vector3
        function _G.Vector3.new(x, y, z)
            return setmetatable({X = x or 0, Y = y or 0, Z = z or 0}, _G.Vector3)
        end
        _G.Vector3.zero = _G.Vector3.new(0, 0, 0)
        _G.Vector3.one = _G.Vector3.new(1, 1, 1)
        function _G.Vector3.__add(a, b) return _G.Vector3.new(a.X + b.X, a.Y + b.Y, a.Z + b.Z) end
        function _G.Vector3.__sub(a, b) return _G.Vector3.new(a.X - b.X, a.Y - b.Y, a.Z - b.Z) end
        function _G.Vector3.__mul(a, b)
            if type(b) == "number" then return _G.Vector3.new(a.X * b, a.Y * b, a.Z * b) end
            return _G.Vector3.new(a.X * b.X, a.Y * b.Y, a.Z * b.Z)
        end
        function _G.Vector3.__tostring(self) return self.X .. ", " .. self.Y .. ", " .. self.Z end

        -- CFrame
        _G.CFrame = {}
        _G.CFrame.__index = _G.CFrame
        function _G.CFrame.new(...) return setmetatable({}, _G.CFrame) end
        function _G.CFrame.Angles(...) return _G.CFrame.new() end
        function _G.CFrame.fromEulerAnglesXYZ(...) return _G.CFrame.new() end
        function _G.CFrame.__mul(a, b) return a end
        function _G.CFrame:ToEulerAnglesXYZ() return 0, 0, 0 end

        -- Ğ”Ñ€ÑƒĞ³Ğ¸Ğµ Ñ‚Ğ¸Ğ¿Ñ‹
        _G.UDim2 = {new = function(...) return {} end, fromScale = function(...) return {} end, fromOffset = function(...) return {} end}
        _G.Color3 = {new = function(...) return {} end, fromRGB = function(...) return {} end, fromHSV = function(...) return {} end}
        _G.BrickColor = {new = function(...) return {} end, Random = function() return {} end}
        _G.NumberRange = {new = function(...) return {} end}
        _G.NumberSequence = {new = function(...) return {} end}
        _G.ColorSequence = {new = function(...) return {} end}
        _G.Ray = {new = function(...) return {} end}
        
        -- Enum
        _G.Enum = setmetatable({}, {
            __index = function(t, k)
                return setmetatable({}, {
                    __index = function(t2, k2)
                        return {Value = 0, Name = k2, EnumType = k}
                    end
                })
            end
        })

        -- Task library
        _G.task = {
            wait = function(t) return t or 0 end,
            spawn = function(f, ...) pcall(f, ...) end,
            defer = function(f, ...) pcall(f, ...) end,
            delay = function(t, f, ...) pcall(f, ...) end,
            cancel = function() end,
            synchronize = function() return function() end end,
            desynchronize = function() end
        }
        _G.wait = _G.task.wait
        _G.spawn = _G.task.spawn
        _G.delay = _G.task.delay

        -- Game structure
        _G.game = _G.Instance.new("DataModel")
        _G.game.PlaceId = 123456789
        _G.game.GameId = 987654321
        _G.game.JobId = "test-job-id"
        
        -- Players
        _G.game.Players = _G.Instance.new("Players")
        _G.game.Players.LocalPlayer = _G.Instance.new("Player")
        _G.game.Players.LocalPlayer.Name = "DeobfUser"
        _G.game.Players.LocalPlayer.UserId = 123456
        _G.game.Players.LocalPlayer.Character = _G.Instance.new("Model")
        _G.game.Players.LocalPlayer.Character.Humanoid = _G.Instance.new("Humanoid")
        _G.game.Players.LocalPlayer.PlayerGui = _G.Instance.new("PlayerGui")
        
        function _G.game.Players:GetPlayers() return {_G.game.Players.LocalPlayer} end
        
        -- RunService
        _G.game.RunService = _G.Instance.new("RunService")
        _G.game.RunService.RenderStepped = CreateSignal()
        _G.game.RunService.Heartbeat = CreateSignal()
        _G.game.RunService.Stepped = CreateSignal()
        function _G.game.RunService:IsClient() return true end
        function _G.game.RunService:IsServer() return false end
        function _G.game.RunService:IsStudio() return false end
        
        -- HttpService
        _G.game.HttpService = _G.Instance.new("HttpService")
        function _G.game.HttpService:JSONEncode(t) return "{}" end
        function _G.game.HttpService:JSONDecode(s) return {} end
        function _G.game.HttpService:UrlEncode(s) return s end
        function _G.game.HttpService:GenerateGUID() return "MOCK-GUID-12345" end
        function _G.game.HttpService:GetAsync(url)
            log_action("ğŸŒ HttpService:GetAsync(" .. tostring(url) .. ")")
            return "<mock response>"
        end
        function _G.game.HttpService:PostAsync(url, data)
            log_action("ğŸŒ HttpService:PostAsync(" .. tostring(url) .. ")")
            return "<mock response>"
        end
        
        -- ReplicatedStorage
        _G.game.ReplicatedStorage = _G.Instance.new("ReplicatedStorage")
        
        -- Workspace
        _G.workspace = _G.Instance.new("Workspace")
        _G.game.Workspace = _G.workspace
        
        -- Script context
        _G.script = _G.Instance.new("LocalScript")
        _G.script.Parent = _G.workspace
        
        -- GetService
        function _G.game:GetService(serviceName)
            if serviceName == "Players" then return _G.game.Players end
            if serviceName == "RunService" then return _G.game.RunService end
            if serviceName == "HttpService" then return _G.game.HttpService end
            if serviceName == "ReplicatedStorage" then return _G.game.ReplicatedStorage end
            if serviceName == "Workspace" then return _G.workspace end
            if serviceName == "Lighting" then return _G.Instance.new("Lighting") end
            if serviceName == "StarterGui" then return _G.Instance.new("StarterGui") end
            if serviceName == "UserInputService" then return _G.Instance.new("UserInputService") end
            if serviceName == "TweenService" then return _G.Instance.new("TweenService") end
            return _G.Instance.new(serviceName)
        end

        -- Exploit environment functions
        _G.getgenv = function() return _G end
        _G.getrenv = function() return _G end
        _G.getreg = function() return {} end
        _G.getgc = function(include_tables) return {} end
        _G.getloadedmodules = function() return {} end
        _G.getconnections = function(signal) return {} end
        _G.getcallingscript = function() return _G.script end
        _G.checkcaller = function() return true end
        _G.islclosure = function(f) return type(f) == "function" end
        _G.iscclosure = function(f) return false end
        _G.newcclosure = function(f) return f end
        _G.hookfunction = function(old, new) return old end
        _G.hookmetamethod = function(obj, method, hook) return function() end end
        _G.getnamecallmethod = function() return "" end
        _G.getcallstacksize = function() return 0 end
        _G.isreadonly = function(t) return false end
        _G.setreadonly = function(t, val) end
        _G.isrbxactive = function() return true end
        _G.getrawmetatable = function(obj) return getmetatable(obj) or {} end
        _G.setrawmetatable = function(obj, mt) return setmetatable(obj, mt) end
        
        -- HttpGet/HttpPost (ÑƒÑÑ‚Ğ°Ñ€ĞµĞ²ÑˆĞ¸Ğµ)
        _G.game.HttpGet = function(self, url)
            log_action("ğŸŒ game:HttpGet(" .. tostring(url) .. ")")
            return "<mock html>"
        end
        _G.game.HttpPost = function(self, url, data)
            log_action("ğŸŒ game:HttpPost(" .. tostring(url) .. ")")
            return "<mock response>"
        end

        -- ============================================
        -- Ğ¤Ğ˜ĞĞĞ›Ğ¬ĞĞ«Ğ™ Ğ”ĞĞœĞŸ
        -- ============================================
        function _G.dump_globals()
            local ignore_keys = {
                string = 1, math = 1, table = 1, bit = 1, bit32 = 1, 
                coroutine = 1, debug = 1, io = 1, os = 1, package = 1,
                _G = 1, _VERSION = 1, assert = 1, collectgarbage = 1,
                dofile = 1, error = 1, getmetatable = 1, ipairs = 1,
                load = 1, loadstring = 1, next = 1, pairs = 1, pcall = 1,
                print = 1, rawequal = 1, rawget = 1, rawlen = 1, rawset = 1,
                require = 1, select = 1, setmetatable = 1, tonumber = 1,
                tostring = 1, type = 1, unpack = 1, xpcall = 1, warn = 1,
                Instance = 1, Vector3 = 1, CFrame = 1, UDim2 = 1, Color3 = 1,
                BrickColor = 1, Enum = 1, task = 1, wait = 1, spawn = 1,
                delay = 1, game = 1, workspace = 1, script = 1,
                getgenv = 1, getrenv = 1, getreg = 1, getgc = 1,
                CAPTURED_CHUNKS = 1, DETECTED_STRINGS = 1, REMOTE_CALLS = 1,
                ACTION_LOG = 1, FINAL_GLOBALS = 1, FUNCTION_CALLS = 1,
                DECRYPTED_DATA = 1, dump_globals = 1, log_action = 1,
                capture_string = 1, CreateSignal = 1, CreateRemoteEvent = 1,
                CreateRemoteFunction = 1
            }
            
            for k, v in pairs(_G) do
                if not ignore_keys[k] then
                    local vtype = type(v)
                    if vtype == "string" or vtype == "number" or vtype == "boolean" then
                        local value_str = tostring(v)
                        if #value_str < 200 then
                            table.insert(_G.FINAL_GLOBALS, tostring(k) .. " = " .. value_str)
                        else
                            table.insert(_G.FINAL_GLOBALS, tostring(k) .. " = <long string: " .. #value_str .. " chars>")
                        end
                    elseif vtype == "function" then
                        table.insert(_G.FINAL_GLOBALS, tostring(k) .. " = <function>")
                    elseif vtype == "table" then
                        table.insert(_G.FINAL_GLOBALS, tostring(k) .. " = <table>")
                    end
                end
            end
        end
        
        log_action("âœ… Environment initialized successfully")
        """

        try:
            update_status("ğŸŒªï¸ Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° ÑÑ€ĞµĞ´Ñ‹ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ...")
            lua.execute(advanced_env)
            
            update_status("ğŸš€ Ğ—Ğ°Ğ¿ÑƒÑĞº ÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ° Ñ Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¼ Ğ¿ĞµÑ€ĞµÑ…Ğ²Ğ°Ñ‚Ğ¾Ğ¼...")
            
            runner = lua.eval("""
                function(code)
                    local success, err = pcall(function()
                        -- ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ ĞºĞ°Ğº ÑÑ‚Ñ€Ğ¾ĞºÑƒ
                        local func, load_err = load(code, "deobf_script", "t", _G)
                        if not func then
                            log_action("âŒ Load error: " .. tostring(load_err))
                            error(load_err)
                        end
                        
                        -- Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼
                        func()
                    end)
                    
                    if not success then
                        log_action("âŒ Execution error: " .. tostring(err))
                    else
                        log_action("âœ… Script executed successfully")
                    end
                    
                    -- Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ„Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
                    pcall(_G.dump_globals)
                    
                    return success
                end
            """)
            
            runner(content)

            # Ğ¡Ğ±Ğ¾Ñ€ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ¾Ğ²
            strings_dict = lua.globals().DETECTED_STRINGS
            detected_strings = []
            for s in strings_dict:
                count = strings_dict[s]
                detected_strings.append((s, count))
            
            # Ğ¡Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚Ğµ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
            detected_strings.sort(key=lambda x: x[1], reverse=True)
            
            global_dump = list(lua.globals().FINAL_GLOBALS)
            action_log = list(lua.globals().ACTION_LOG)
            remote_calls = lua.globals().REMOTE_CALLS
            chunks = lua.globals().CAPTURED_CHUNKS
            
            # Ğ˜Ğ·Ğ²Ğ»ĞµĞºĞ°ĞµĞ¼ RemoteSpy Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
            remote_log = []
            if len(remote_calls) > 0:
                for i in range(1, len(remote_calls) + 1):
                    call = remote_calls[i]
                    remote_log.append({
                        'type': call.type,
                        'name': call.name,
                        'direction': call.direction,
                        'args': list(call.args) if call.args else []
                    })
            
            # ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ ÑĞ°Ğ¼Ñ‹Ğ¹ Ğ±Ğ¾Ğ»ÑŒÑˆĞ¾Ğ¹ Ñ‡Ğ°Ğ½Ğº (Ğ²ĞµÑ€Ğ¾ÑÑ‚Ğ½Ğ¾ Ñ€Ğ°ÑĞ¿Ğ°ĞºĞ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ĞºĞ¾Ğ´)
            best_chunk = None
            max_size = 0
            if len(chunks) > 0:
                for i in range(1, len(chunks) + 1):
                    c = chunks[i]
                    if c.type == "string" and c.size > max_size:
                        max_size = c.size
                        best_chunk = c.data
            
            target_code = best_chunk if best_chunk else content
            
            return self._finalize_output(
                target_code, 
                detected_strings, 
                global_dump, 
                action_log,
                remote_log,
                update_status
            )

        except Exception as e:
            logger.error(f"Engine Crash: {e}", exc_info=True)
            return f"-- [CRASH ERROR]: {str(e)}".encode('utf-8')

    def _clean_string(self, s):
        if isinstance(s, bytes):
            try: return s.decode('utf-8', errors='replace')
            except: return str(s)
        return str(s)

    def _finalize_output(self, code_bytes, strings_with_count, globals_dump, logs, remote_calls, callback):
        if callback: callback("ğŸ“ Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚Ğ°...")
        
        final_text = "-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n"
        final_text += "-- â•‘       ROBLOX LUAU DEOBFUSCATOR V4 - REPORT          â•‘\n"
        final_text += "-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n"
        
        # RemoteSpy ÑĞµĞºÑ†Ğ¸Ñ
        if remote_calls:
            final_text += "-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"
            final_text += "-- â”‚              ğŸ”´ REMOTE SPY CAPTURES                 â”‚\n"
            final_text += "-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n"
            for call in remote_calls[:50]:  # Ğ¢Ğ¾Ğ¿ 50 Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğ¾Ğ²
                final_text += f"-- [{call['type']}] {call['name']}:{call['direction']}\n"
                if call['args']:
                    final_text += f"--   Args: {call['args']}\n"
            final_text += "\n"
        
        # Ğ¢Ğ¾Ğ¿ ÑÑ‚Ñ€Ğ¾Ğº (Ğ¿Ğ¾ Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚Ğµ)
        if strings_with_count:
            final_text += "-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"
            final_text += "-- â”‚           ğŸ“œ EXTRACTED STRINGS (TOP 100)            â”‚\n"
            final_text += "-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n"
            
            for s, count in strings_with_count[:100]:
                clean = self._clean_string(s).replace('\n', '\\n').replace('\r', '')
                if len(clean) > 100:
                    clean = clean[:100] + "..."
                final_text += f'-- [{count}x] "{clean}"\n'
            final_text += "\n"
        
        # Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ
        if globals_dump:
            final_text += "-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"
            final_text += "-- â”‚              ğŸŒ GLOBAL VARIABLES                    â”‚\n"
            final_text += "-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n"
            for g in globals_dump[:50]:
                final_text += f"-- {self._clean_string(g)}\n"
            final_text += "\n"
        
        # Ğ›Ğ¾Ğ³Ğ¸ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğ¹
        if logs:
            final_text += "-- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"
            final_text += "-- â”‚                ğŸ“Š EXECUTION LOG                     â”‚\n"
            final_text += "-- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n"
            for l in logs[-30:]:
                final_text += f"-- {self._clean_string(l)}\n"
            final_text += "\n"
        
        # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ ĞºĞ¾Ğ´
        final_text += "-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n"
        final_text += "-- â•‘                  ğŸ’ MAIN SOURCE CODE                 â•‘\n"
        final_text += "-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n"
        
        try:
            if isinstance(code_bytes, bytes):
                source = code_bytes.decode('utf-8', errors='replace')
            else:
                source = str(code_bytes)
            
            final_text += self._beautify_lua(source)
        except Exception as e:
            final_text += f"-- [ERROR decoding source]: {e}\n"
            final_text += f"-- Hex dump: {binascii.hexlify(code_bytes[:500])}\n"
        
        return final_text.encode('utf-8')

    def _beautify_lua(self, source_code):
        """Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ¾Ğµ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Lua ĞºĞ¾Ğ´Ğ°"""
        # Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿ĞµÑ€ĞµĞ½Ğ¾ÑÑ‹ ÑÑ‚Ñ€Ğ¾Ğº Ğ¿Ğ¾ÑĞ»Ğµ ĞºĞ»ÑÑ‡ĞµĞ²Ñ‹Ñ… ÑĞ»Ğ¾Ğ²
        keywords = ['then', 'do', 'repeat', 'else', 'elseif']
        for kw in keywords:
            source_code = re.sub(rf'\s+{kw}\s+', f' {kw}\n', source_code)
        
        # Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ end
        source_code = re.sub(r'\s+end\s+', '\nend\n', source_code)
        
        # Ğ¢Ğ¾Ñ‡ĞºĞ° Ñ Ğ·Ğ°Ğ¿ÑÑ‚Ğ¾Ğ¹
        source_code = source_code.replace(';', ';\n')
        
        return source_code
