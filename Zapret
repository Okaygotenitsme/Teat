import re
import base64
import binascii

class StaticDecoder:
    @staticmethod
    def process(content_bytes):
        """
        Пытается статически деобфусцировать скрипт.
        Возвращает: (Success: bool, Result: str/bytes, Method: str)
        """
        try:
            content = content_bytes.decode('utf-8', 'ignore')
        except:
            return False, None, None

        # --- 1. VEXON HUB (String Length) ---
        # Паттерн: rrCCRDIBKJYVYTET({'$$$', '$$', ...})
        if "string.len" in content and "table.concat" in content:
            vexon_table = re.search(r"\{('[^']+',\s*)+'[^']+'\}", content)
            if vexon_table:
                try:
                    raw_strings = re.findall(r"'([^']+)'", vexon_table.group(0))
                    decoded_chars = [chr(len(s)) for s in raw_strings]
                    result = "".join(decoded_chars)
                    if StaticDecoder._is_valid_lua(result):
                        return True, StaticDecoder._beautify(result), "VexonHub (Len Encoding)"
                except: pass

        # --- 2. UNIVERSAL ARRAY XOR (BRUTE FORCE) ---
        # Подходит для: Meloten, GarouTe, IronBrew, PSU
        # Ищем массив чисел {123, 22, 10...} и перебираем ключи
        arrays = re.findall(r"\{((?:\d+,\s*){20,}\d+)\}", content)
        if arrays:
            # Берем самый длинный массив (вероятно это пейлоад)
            longest_array = max(arrays, key=len)
            try:
                nums = [int(x) for x in longest_array.split(',')]
                # Если массив байтов (0-255)
                if all(0 <= n <= 255 for n in nums[:20]): 
                    # Пробуем перебор ключей от 0 до 255
                    for key in range(256):
                        try:
                            # XOR операция
                            decoded_chars = [chr(n ^ key) for n in nums]
                            candidate = "".join(decoded_chars)
                            
                            # Проверяем, похож ли результат на Луа код
                            if StaticDecoder._is_valid_lua(candidate):
                                return True, StaticDecoder._beautify(candidate), f"Byte XOR (BruteKey: {key})"
                        except: continue
            except: pass

        # --- 3. DECIMAL / CHAR DUMP ---
        # Паттерн: string.char(108, 111, 99, 97, 108) -> "local"
        if "string.char" in content:
            char_matches = re.findall(r"string\.char\(([\d,\s]+)\)", content)
            for match in char_matches:
                try:
                    nums = [int(x) for x in match.split(',')]
                    decoded = "".join(chr(n) for n in nums)
                    if len(decoded) > 20 and StaticDecoder._is_valid_lua(decoded):
                        return True, StaticDecoder._beautify(decoded), "Decimal/Char Dump"
                except: pass

        # --- 4. REVERSE STRING ---
        # Паттерн: string.reverse("...edoc...")
        reverse_match = re.search(r"string\.reverse\(['\"](.*?)['\"]\)", content)
        if reverse_match:
            try:
                reversed_str = reverse_match.group(1)[::-1] # Переворачиваем обратно
                if StaticDecoder._is_valid_lua(reversed_str):
                    return True, StaticDecoder._beautify(reversed_str), "Reverse String"
            except: pass

        # --- 5. BASE64 LAYER ---
        # Ищем большие куски Base64
        b64_matches = re.findall(r'["\']([A-Za-z0-9+/]{50,}={0,2})["\']', content)
        for b64 in b64_matches:
            try:
                decoded = base64.b64decode(b64).decode('utf-8')
                if StaticDecoder._is_valid_lua(decoded):
                    return True, StaticDecoder._beautify(decoded), "Base64 Layer"
            except: pass

        return False, None, None

    @staticmethod
    def _is_valid_lua(text):
        """Проверяет, похож ли текст на Lua код"""
        keywords = ["local ", "function ", "game:", "return ", "if ", "end)", "end"]
        # Должен содержать хотя бы 2 ключевых слова
        count = sum(1 for k in keywords if k in text)
        return count >= 2

    @staticmethod
    def _beautify(source_code):
        """Делает код читаемым"""
        source_code = re.sub(r'(\s)(local|return|if|for|while|repeat|function)(\s)', r'\n\2 ', source_code)
        replacements = {
            " then ": " then\n", " do ": " do\n", " end ": "\nend\n",
            " repeat ": "\nrepeat\n", " until ": "\nuntil ", ";": ";\n",
            "(){": "() {"
        }
        for k, v in replacements.items():
            source_code = source_code.replace(k, v)
        return source_code
