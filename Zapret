import lupa
from lupa import LuaRuntime
import logging
import subprocess
import os
import tempfile
import re
import binascii
import base64

# –õ–æ–≥–≥–µ—Ä
logger = logging.getLogger("DeobfuscatorEngine")

class StaticDeobfuscator:
    """
    –ö–ª–∞—Å—Å –¥–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–Ω—è—Ç–∏—è —Å–ª–∞–±–æ–π –∑–∞—â–∏—Ç—ã (XOR, Base64, Table Encoding)
    –±–µ–∑ –∑–∞–ø—É—Å–∫–∞ Lua —Å—Ä–µ–¥—ã.
    """
    
    @staticmethod
    def detect_and_solve(content_str):
        logs = []
        
        # 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ VexonHub (–î–ª–∏–Ω–∞ —Å—Ç—Ä–æ–∫ –≤ —Ç–∞–±–ª–∏—Ü–µ)
        # –ü–∞—Ç—Ç–µ—Ä–Ω: —Ñ—É–Ω–∫—Ü–∏—è( {'$$$', '$$', ...} )
        if "string.len" in content_str and "table.concat" in content_str and "string.char" in content_str:
            vexon_match = re.search(r"\{('[^']+',\s*)+'[^']+'\}", content_str)
            if vexon_match:
                try:
                    logs.append("üîç –û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–∞—Ç—Ç–µ—Ä–Ω: VexonHub (String Length Encoding)")
                    table_str = vexon_match.group(0)
                    # –í—ã—Ç–∞—Å–∫–∏–≤–∞–µ–º –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ –≤–Ω—É—Ç—Ä–∏ –∫–∞–≤—ã—á–µ–∫
                    parts = re.findall(r"'([^']+)'", table_str)
                    decoded = []
                    for p in parts:
                        decoded.append(chr(len(p)))
                    res = "".join(decoded)
                    return res, logs
                except Exception as e:
                    logs.append(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ Vexon –¥–µ–∫–æ–¥–µ—Ä–∞: {e}")

        # 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ Byte Array XOR (Meloten / GarouTe)
        # –ü–∞—Ç—Ç–µ—Ä–Ω: local table = {123, 234, ...} –∏ –ø–æ—Å–ª–µ–¥—É—é—â–∏–π bxor
        # –ò—â–µ–º –º–∞—Å—Å–∏–≤ —á–∏—Å–µ–ª
        array_match = re.search(r"\{((?:\d+,\s*)*\d+)\}", content_str)
        if array_match:
            # –ï—Å–ª–∏ –º–∞—Å—Å–∏–≤ —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π, —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–æ—Å—Ç–æ Vector3 –∏–ª–∏ Color3, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
            nums_str = array_match.group(1)
            nums = [int(x) for x in nums_str.split(',')]
            
            if len(nums) > 50: # –¢–æ–ª—å–∫–æ –µ—Å–ª–∏ –º–∞—Å—Å–∏–≤ –±–æ–ª—å—à–æ–π
                # –ò—â–µ–º –∫–ª—é—á XOR (—á–∞—Å—Ç–æ —ç—Ç–æ —á–∏—Å–ª–æ —Ä—è–¥–æ–º —Å bxor –∏–ª–∏ bit.bxor)
                # –ü–∞—Ç—Ç–µ—Ä–Ω: bxor(a, 123) –∏–ª–∏ bxor(v, key)
                key_match = re.search(r"(?:bxor|xor)\s*\(\s*[^,]+,\s*(\d+)\s*\)", content_str)
                
                # –ï—Å–ª–∏ —è–≤–Ω–æ–≥–æ –∫–ª—é—á–∞ –Ω–µ—Ç, –ø—Ä–æ–±—É–µ–º –ø–µ—Ä–µ–±–æ—Ä–æ–º –∏–ª–∏ –∏—â–µ–º –ø—Ä–æ—Å—Ç—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
                key = int(key_match.group(1)) if key_match else None
                
                if key:
                    logs.append(f"üîç –û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–∞—Ç—Ç–µ—Ä–Ω: Mass Array XOR (Key: {key})")
                    try:
                        decoded_chars = [chr(n ^ key) for n in nums]
                        return "".join(decoded_chars), logs
                    except: pass
                
                # –ï—Å–ª–∏ —ç—Ç–æ Meloten/GarouTe –±–µ–∑ —è–≤–Ω–æ–≥–æ xor (—Å–ª–æ–∂–Ω–∞—è –º–∞—Ç. –æ–ø–µ—Ä–∞—Ü–∏—è),
                # –∏–Ω–æ–≥–¥–∞ –æ–Ω–∏ –ø—Ä–æ—Å—Ç–æ –≤—ã—á–∏—Ç–∞—é—Ç —á–∏—Å–ª–æ. –ü—Ä–æ–±—É–µ–º —ç–≤—Ä–∏—Å—Ç–∏–∫—É (—á–∞—Å—Ç–æ –∫–æ–¥ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å "local" –∏–ª–∏ "--")
                # –ù–æ –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏ –ª—É—á—à–µ –æ—Å—Ç–∞–≤–∏—Ç—å —ç—Ç–æ –Ω–∞ VM, –µ—Å–ª–∏ —Å—Ç–∞—Ç–∏–∫–∞ –Ω–µ –Ω–∞—à–ª–∞ XOR.

        # 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ Base64
        # –ò—â–µ–º –¥–ª–∏–Ω–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏ –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤, –∫—Ä–∞—Ç–Ω—ã–µ 4, –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—â–∏–µ—Å—è –Ω–∞ =
        b64_matches = re.findall(r'["\']([A-Za-z0-9+/]{50,}={0,2})["\']', content_str)
        for b64 in b64_matches:
            try:
                decoded = base64.b64decode(b64).decode('utf-8')
                # –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ—Ö–æ–∂ –Ω–∞ –∫–æ–¥
                if "local" in decoded or "function" in decoded or "game:" in decoded:
                    logs.append("üîç –û–±–Ω–∞—Ä—É–∂–µ–Ω –ø–∞—Ç—Ç–µ—Ä–Ω: Base64 String")
                    return decoded, logs
            except:
                pass

        return None, logs

class DeobfuscatorEngine:
    def __init__(self):
        base_dir = os.path.dirname(os.path.abspath(__file__))
        self.unluac_path = os.path.join(base_dir, "unluac.jar")
        logger.info(f"üìÅ Working Dir: {base_dir}")

    def process(self, content_bytes, status_callback=None):
        def update_status(msg):
            if status_callback: status_callback(msg)
            logger.info(f"[STATUS] {msg}")

        # –î–µ–∫–æ–¥–∏—Ä—É–µ–º –±–∞–π—Ç—ã –≤ —Å—Ç—Ä–æ–∫—É –¥–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
        try:
            content_str = content_bytes.decode('utf-8', errors='ignore')
        except:
            content_str = ""

        # --- –≠–¢–ê–ü 1: –°–¢–ê–¢–ò–ß–ï–°–ö–ê–Ø –î–ï–û–ë–§–£–°–ö–ê–¶–ò–Ø (–ë–´–°–¢–†–ê–Ø) ---
        update_status("‚ö° –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ (Signature Scanning)...")
        static_result, static_logs = StaticDeobfuscator.detect_and_solve(content_str)
        
        if static_result:
            update_status("‚úÖ –£—Å–ø–µ—à–Ω–æ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏!")
            final_output = "-- [[ STATIC DEOBFUSCATION SUCCESS ]] --\n"
            for log in static_logs:
                final_output += f"-- {log}\n"
            final_output += "\n" + self._beautify_lua(static_result)
            return final_output.encode('utf-8')

        # --- –≠–¢–ê–ü 2: –î–ò–ù–ê–ú–ò–ß–ï–°–ö–ê–Ø –≠–ú–£–õ–Ø–¶–ò–Ø (–ï–°–õ–ò –°–¢–ê–¢–ò–ö–ê –ù–ï –°–ü–†–ê–í–ò–õ–ê–°–¨) ---
        if not self._check_java():
            return b"-- [FATAL] Java is missing. Install Java to use unluac."
        
        update_status("üß† –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ä–µ–¥—ã Roblox (Emulation V3)...")

        # --- –ù–ê–°–¢–†–û–ô–ö–ê LUA VM ---
        try:
            lua = LuaRuntime(unpack_returned_tuples=True, encoding=None)
        except Exception as e:
            return f"-- [FATAL] Lua start error: {e}".encode('utf-8')

        # –ü–û–õ–ò–§–ò–õ–õ–´ (BITWISE) - –í–∞–∂–Ω–æ –¥–ª—è XOR —Å–∫—Ä–∏–ø—Ç–æ–≤
        bit_polyfill = """
        local bit = {}
        function bit.tobit(x) x = x % 4294967296; if x >= 2147483648 then x = x - 4294967296 end; return x end
        function bit.bnot(x) return 4294967295 - x % 4294967296 end
        local function bit_oper(a, b, oper)
            local r, m, s = 0, 2^31, nil
            repeat s,a,b = a+b+m, a%m, b%m; r,m = r + m*oper%(s-a-b), m/2 until m < 1
            return r
        end
        function bit.band(a, b) return bit_oper(a, b, 4) end
        function bit.bor(a, b)  return bit_oper(a, b, 1) end
        function bit.bxor(a, b) return bit_oper(a, b, 3) end
        function bit.lshift(a, b) return (a * 2^b) % 4294967296 end
        function bit.rshift(a, b) return math.floor(a / 2^b) % 4294967296 end
        function bit.arshift(a, b) 
            local z = math.floor(a / 2^b) % 4294967296
            if a >= 2147483648 then z = z + 4294967296 - 2^(32-b) end
            return z
        end
        package.loaded.bit = bit;
        _G.bit = bit; _G.bit32 = bit 
        """

        # ROBLOX API EMULATION (–°–æ–∫—Ä–∞—â–µ–Ω–æ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π —Å–≤–æ–π –ø–æ–ª–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç)
        roblox_emu = """
        local function CreateSignal()
            local sig = {}
            local callbacks = {}
            function sig:Connect(func) table.insert(callbacks, func); return {Disconnect=function() end} end
            function sig:Fire(...) for _, f in ipairs(callbacks) do pcall(f, ...) end end
            function sig:Wait() return 0 end
            return sig
        end
        _G.Instance = { new = function(c, p) 
            local o = {Name=c, ClassName=c, Parent=p, Children={}} 
            return setmetatable(o, {__index=function(t,k) return rawget(t,k) end, __newindex=function(t,k,v) rawset(t,k,v) end})
        end}
        _G.Vector3 = {new=function(x,y,z) return {X=x or 0, Y=y or 0, Z=z or 0} end}
        _G.CFrame = {new=function(...) return {} end}
        _G.game = _G.Instance.new("DataModel")
        _G.game:GetService("HttpService").JSONDecode = function(s) return {} end
        _G.wait = function(t) return 0 end
        _G.spawn = function(f) pcall(f) end
        _G.script = _G.Instance.new("Script")
        """

        # SPYWARE HOOKS (–£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
        spyware = """
        _G.CAPTURED_CHUNKS = {}
        _G.DETECTED_STRINGS = {}
        _G.ACTION_LOG = {}
        _G.FINAL_GLOBALS = {}
        
        local function log_action(msg) if #_G.ACTION_LOG < 500 then table.insert(_G.ACTION_LOG, msg) end end
        local function capture_str(s) 
            if type(s) == "string" and #s > 4 then _G.DETECTED_STRINGS[s] = true end 
            return s
        end

        -- –•—É–∫ loadstring –¥–ª—è –ø–µ—Ä–µ—Ö–≤–∞—Ç–∞ –¥–µ–æ–±—Ñ—É—Å—Ü–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ–¥–∞
        local real_load = load
        local function hooked_load(chunk, name, mode, env)
            if type(chunk) == "string" and #chunk > 50 then
                table.insert(_G.CAPTURED_CHUNKS, {data = chunk, size = #chunk})
                log_action("üî• Captured Chunk Size: " .. #chunk)
            end
            return real_load(chunk, name, mode, env)
        end
        _G.load = hooked_load
        _G.loadstring = hooked_load
        
        -- –•—É–∫ string.char (–¥–ª—è —Å–±–æ—Ä–∫–∏ —Å—Ç—Ä–æ–∫)
        local real_char = string.char
        string.char = function(...)
            local res = real_char(...)
            -- –ï—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ –¥–ª–∏–Ω–Ω–∞—è, –≤–æ–∑–º–æ–∂–Ω–æ —ç—Ç–æ –∫–æ–¥
            if #res > 20 then capture_str(res) end
            return res
        end
        
        -- –§—É–Ω–∫—Ü–∏—è –¥–∞–º–ø–∞ –≥–ª–æ–±–∞–ª–æ–≤
        function _G.dump_globals()
            for k, v in pairs(getfenv()) do
                if type(v) == "string" and #v > 10 then table.insert(_G.FINAL_GLOBALS, k.." = "..v) end
            end
        end
        """

        full_setup = bit_polyfill + "\n" + roblox_emu + "\n" + spyware

        try:
            update_status("üå™Ô∏è –ó–∞–ø—É—Å–∫ —Å–∫—Ä–∏–ø—Ç–∞ —Å —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–æ–π...")
            lua.execute(full_setup)
            
            # –ó–∞–ø—É—Å–∫–∞–µ–º —Å–∫—Ä–∏–ø—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            runner = lua.eval("""
                function(code)
                    local status, err = pcall(function()
                        local f = load(code)
                        if f then f() end
                    end)
                    if not status then table.insert(_G.ACTION_LOG, "‚ùå Error: " .. tostring(err)) end
                    pcall(_G.dump_globals)
                end
            """)
            runner(content_bytes)

            # --- –°–ë–û–† –†–ï–ó–£–õ–¨–¢–ê–¢–û–í ---
            chunks = list(lua.globals().CAPTURED_CHUNKS)
            strings = list(lua.globals().DETECTED_STRINGS)
            
            # –ò—â–µ–º –ª—É—á—à–∏–π —á–∞–Ω–∫ (–∫–æ–¥ –≤–Ω—É—Ç—Ä–∏ loadstring)
            best_code = None
            max_len = 0
            for c in chunks:
                if c.size > max_len:
                    max_len = c.size
                    best_code = c.data

            target_code = best_code if best_code else content_bytes
            
            return self._finalize_output(target_code, strings, list(lua.globals().ACTION_LOG), update_status)

        except Exception as e:
            logger.error(f"Engine Crash: {e}")
            return f"-- [CRASH ERROR]: {str(e)}".encode('utf-8')

    def _check_java(self):
        try:
            subprocess.run(["java", "-version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return True
        except: return False

    def _finalize_output(self, code_data, strings, logs, callback):
        if callback: callback("üß¨ –§–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞...")
        
        # –ï—Å–ª–∏ code_data —ç—Ç–æ –±–∞–π—Ç—ã, –ø—Ä–æ–±—É–µ–º –¥–µ–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å
        decompiled = None
        is_bytecode = False
        
        if isinstance(code_data, str):
            code_str = code_data # –≠—Ç–æ —É–∂–µ –∏—Å—Ö–æ–¥–Ω–∏–∫
        else:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∏–≥–Ω–∞—Ç—É—Ä—É Lua Bytecode (–æ–±—ã—á–Ω–æ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å ESC Lua)
            if code_data.startswith(b'\x1bLua'):
                is_bytecode = True
                decompiled = self._try_decompile(code_data)
                code_str = decompiled.decode('utf-8', 'ignore') if decompiled else "-- [Unluac Failed]"
            else:
                code_str = code_data.decode('utf-8', 'ignore')

        final_text = "-- [[ DEOBFUSCATOR V2 OUTPUT ]] --\n"
        if logs:
            final_text += "-- LOGS:\n" + "\n".join([f"-- {l}" for l in logs[-10:]]) + "\n\n"
        
        final_text += "-- [[ SOURCE CODE ]] --\n"
        final_text += self._beautify_lua(code_str)

        return final_text.encode('utf-8')

    def _try_decompile(self, bytecode):
        if not os.path.exists(self.unluac_path): return None
        try:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".lua", mode='wb') as tmp:
                tmp.write(bytecode)
                path = tmp.name
            
            res = subprocess.run(
                ["java", "-jar", self.unluac_path, path], 
                capture_output=True, timeout=10
            )
            os.remove(path)
            if res.returncode == 0: return res.stdout
            return None
        except: return None

    def _beautify_lua(self, source_code):
        # –ü—Ä–æ—Å—Ç–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        indent = 0
        lines = source_code.split('\n')
        formatted = []
        for line in lines:
            line = line.strip()
            if not line: continue
            
            # –£–º–µ–Ω—å—à–∞–µ–º –æ—Ç—Å—Ç—É–ø –¥–ª—è –∑–∞–∫—Ä—ã–≤–∞—é—â–∏—Ö –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–π
            if line.startswith("end") or line.startswith("until") or line.startswith("}"):
                indent = max(0, indent - 1)
            
            formatted.append("\t" * indent + line)
            
            # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –æ—Ç—Å—Ç—É–ø –¥–ª—è –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏—Ö
            if line.endswith("then") or line.endswith("do") or line.endswith("repeat") or line.endswith("{") or "function" in line:
                if not line.endswith("end"): # –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ–¥–Ω–æ—Å—Ç—Ä–æ—á–Ω–∏–∫–∏
                    indent += 1
                    
        return "\n".join(formatted)
