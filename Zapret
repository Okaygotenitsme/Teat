--[[
    ADVANCED LUAU OBFUSCATOR - GoofyScator Level
    Multi-layer VM with encryption, anti-debug and anti-tamper
]]

local Obfuscator = {}
Obfuscator.__index = Obfuscator

-- Утилиты для генерации случайных данных
local function randomString(length)
    local chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"
    local result = ""
    for i = 1, length or math.random(10, 20) do
        local idx = math.random(1, #chars)
        result = result .. chars:sub(idx, idx)
    end
    return result
end

-- XOR шифрование с динамическим ключом
local function advancedXOR(data, key)
    local result = {}
    local keyLen = #key
    local keyHash = 0
    
    for i = 1, #data do
        local byte = string.byte(data, i)
        local keyByte = string.byte(key, ((i - 1) % keyLen) + 1)
        keyHash = (keyHash + byte) % 256
        local encrypted = bit32.bxor(byte, keyByte, keyHash)
        table.insert(result, encrypted)
    end
    
    return result
end

-- Base93 кодирование
local function toBase93(bytes)
    local chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+,-./:;<=>?@[]^_`{|}~"
    local result = ""
    
    local i = 1
    while i <= #bytes do
        local value = 0
        
        for j = 0, 3 do
            if bytes[i + j] then
                value = value * 256 + bytes[i + j]
            end
        end
        
        for _ = 1, 5 do
            local remainder = value % 93
            result = chars:sub(remainder + 1, remainder + 1) .. result
            value = math.floor(value / 93)
        end
        
        i = i + 4
    end
    
    return result
end

-- Создание обфускатора
function Obfuscator.new()
    local self = setmetatable({}, Obfuscator)
    
    math.randomseed(os.time() * os.clock())
    
    self.primaryKey = randomString(64)
    self.secondaryKey = randomString(32)
    
    -- Генерация опкодов
    self.opcodes = {}
    for i = 1, 100 do
        self.opcodes[i] = math.random(10000, 99999)
    end
    
    -- Таблица инструкций VM
    self.instructions = {
        LOAD_CONST = 1,
        GET_GLOBAL = 2,
        SET_GLOBAL = 3,
        CALL = 4,
        RETURN = 5,
    }
    
    return self
end

-- Генерация Anti-Tamper защиты
function Obfuscator:generateAntiTamper()
    local checksum = math.random(100000, 999999)
    local tamperVars = {
        check = randomString(),
        hash = randomString(),
        verify = randomString(),
        original = randomString(),
        current = randomString(),
    }
    
    local antiTamper = string.format([[
local %s = %d
local %s = 0

local function %s(code)
    local sum = 0
    for i = 1, #code do
        sum = sum + string.byte(code, i) * i
    end
    return sum %% 999999
end

local %s = debug and debug.getinfo
if %s then
    local info = %s(1, "S")
    if info and info.source then
        %s = %s(info.source)
        if %s ~= %s then
            error("Code integrity check failed!", 0)
        end
    end
end

local function %s()
    if %s then
        local info = %s(1, "S")
        if info and info.source then
            local %s = %s(info.source)
            if %s ~= %s then
                error("Runtime tampering detected!", 0)
            end
        end
    end
end

local function antiDebug()
    if debug and (debug.getinfo or debug.getlocal or debug.getupvalue) then
        local start = os.clock()
        for i = 1, 1000000 do end
        local elapsed = os.clock() - start
        if elapsed > 0.5 then
            error("Debugger detected!", 0)
        end
    end
end

antiDebug()
%s()
]], 
        tamperVars.original, checksum,
        tamperVars.hash,
        tamperVars.check,
        tamperVars.original, tamperVars.original, tamperVars.original,
        tamperVars.hash, tamperVars.check,
        tamperVars.hash, tamperVars.original,
        tamperVars.verify,
        tamperVars.original, tamperVars.original,
        tamperVars.current, tamperVars.check,
        tamperVars.current, tamperVars.original,
        tamperVars.verify
    )
    
    return antiTamper
end

-- Генерация VM декодера
function Obfuscator:generateVMDecoder()
    local vmVars = {
        key1 = randomString(),
        decoder = randomString(),
    }
    
    local vmCode = string.format([[
local %s = "%s"

local function %s(data)
    local result = {}
    local chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%%&()*+,-./:;<=>?@[]^_`{|}~"
    local bytes = {}
    
    local i = 1
    while i <= #data do
        local value = 0
        for j = 0, 4 do
            local char = data:sub(i + j, i + j)
            local idx = chars:find(char, 1, true)
            if idx then
                value = value * 93 + (idx - 1)
            end
        end
        
        for j = 3, 0, -1 do
            local byte = math.floor(value / (256 ^ j)) %% 256
            table.insert(bytes, byte)
        end
        
        i = i + 5
    end
    
    local keyLen = #%s
    local keyHash = 0
    
    for i = 1, #bytes do
        local byte = bytes[i]
        local keyByte = string.byte(%s, ((i - 1) %% keyLen) + 1)
        keyHash = (keyHash + byte) %% 256
        table.insert(result, string.char(bit32.bxor(byte, keyByte, keyHash)))
    end
    
    return table.concat(result)
end

return %s
]], 
        vmVars.key1, self.primaryKey,
        vmVars.decoder,
        vmVars.key1, vmVars.key1,
        vmVars.decoder
    )
    
    return vmCode
end

-- Генерация мусорного кода
function Obfuscator:generateJunk(amount)
    local junk = {}
    
    for i = 1, amount or math.random(10, 25) do
        local junkType = math.random(1, 5)
        
        if junkType == 1 then
            local var = randomString()
            table.insert(junk, string.format("local %s = %d", var, math.random(1, 10000)))
        elseif junkType == 2 then
            local var1, var2 = randomString(), randomString()
            table.insert(junk, string.format("local %s, %s = %d, %d", var1, var2, math.random(1, 100), math.random(1, 100)))
        elseif junkType == 3 then
            table.insert(junk, string.format("if %d > %d then end", math.random(1, 10), math.random(20, 30)))
        elseif junkType == 4 then
            local var = randomString()
            table.insert(junk, string.format("for %s = 1, 0 do end", var))
        elseif junkType == 5 then
            local var = randomString()
            table.insert(junk, string.format("local %s = \"%s\"", var, randomString(15)))
        end
    end
    
    return table.concat(junk, "\n")
end

-- Основная функция обфускации
function Obfuscator:obfuscate(sourceCode)
    -- Шифруем исходный код
    local encrypted = advancedXOR(sourceCode, self.primaryKey)
    local encoded = toBase93(encrypted)
    
    -- Генерируем компоненты
    local antiTamper = self:generateAntiTamper()
    local vmDecoder = self:generateVMDecoder()
    
    -- Создаём обфусцированный wrapper
    local wrapper = string.format([[
-- Obfuscated with Advanced Luau Obfuscator
-- Protection Level: MAXIMUM
-- Anti-Tamper: ENABLED
-- Timestamp: %s

%s

%s

%s

local decoder = %s
local decoded = decoder("%s")
local executor = loadstring or load
local func = executor(decoded)
if func then func() end
]], 
        os.date("%Y-%m-%d %H:%M:%S"),
        self:generateJunk(30),
        antiTamper,
        vmDecoder,
        randomString(),
        encoded
    )
    
    -- Добавляем второй слой обфускации
    wrapper = self:addControlFlowObfuscation(wrapper)
    
    return wrapper
end

-- Запутывание control flow
function Obfuscator:addControlFlowObfuscation(code)
    local state = randomString()
    local wrapper = randomString()
    local stateValue = math.random(50000, 99999)
    
    return string.format([[
local %s = %d
local %s = function()
    repeat
        if %s == %d then
            %s
            break
        end
        %s = %s + 1
    until %s > 100000
end
%s()
]], 
        state, stateValue,
        wrapper,
        state, stateValue,
        code,
        state, state,
        state,
        wrapper
    )
end

-- CLI
if arg and arg[1] then
    local inputFile = arg[1]
    local outputFile = arg[2] or inputFile:gsub("%.lua$", "_obfuscated.lua")
    
    local file = io.open(inputFile, "r")
    if not file then
        print("Error: Cannot open input file: " .. inputFile)
        os.exit(1)
    end
    
    local sourceCode = file:read("*all")
    file:close()
    
    local obf = Obfuscator.new()
    local obfuscated = obf:obfuscate(sourceCode)
    
    file = io.open(outputFile, "w")
    if not file then
        print("Error: Cannot create output file: " .. outputFile)
        os.exit(1)
    end
    
    file:write(obfuscated)
    file:close()
    
    print(string.format("Successfully obfuscated! Output: %s", outputFile))
    print(string.format("  Original size: %d bytes", #sourceCode))
    print(string.format("  Obfuscated size: %d bytes", #obfuscated))
    print(string.format("  Protection level: MAXIMUM"))
    print(string.format("  Anti-Tamper: ENABLED"))
else
    return Obfuscator
end
