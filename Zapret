import lupa
from lupa import LuaRuntime
import logging
import subprocess
import os
import tempfile
import re
import binascii
import requests
import base64
import hashlib
from typing import Optional, Tuple, List

# –õ–æ–≥–≥–µ—Ä
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("DeobfuscatorEngine")

class DeobfuscatorEngine:
    def __init__(self):
        base_dir = os.path.dirname(os.path.abspath(__file__))
        self.unluac_path = os.path.join(base_dir, "unluac.jar")
        self.http_cache = {}
        logger.info(f"üìÅ Working Dir: {base_dir}")

    # ==========================================
    # ADVANCED PRE-PROCESSING & DETECTION
    # ==========================================
    
    def _detect_and_decode(self, content: bytes) -> Tuple[bytes, List[str]]:
        """
        –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è –¥–µ—Ç–µ–∫—Ü–∏—è –∏ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è IronBrew –∏ MoonSec V3
        """
        detection_log = []
        original_size = len(content)
        
        # === STAGE 0: Python byte string unwrapping ===
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ b'...' –∏–ª–∏ b"..." –æ–±–µ—Ä—Ç–æ–∫
        if content.startswith(b"b'") or content.startswith(b'b"'):
            detection_log.append("üîç Detected Python-style byte string wrapper")
            try:
                # –£–±–∏—Ä–∞–µ–º b' –∏ –∫–æ–Ω–µ—á–Ω—É—é '
                inner = content[2:-1]
                # –î–µ–∫–æ–¥–∏—Ä—É–µ–º escape-–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
                decoded = inner.decode('unicode_escape').encode('latin1')
                detection_log.append(f"  ‚úÖ Unwrapped: {len(content)} -> {len(decoded)} bytes")
                content = decoded
            except Exception as e:
                detection_log.append(f"  ‚ö†Ô∏è Unwrap failed: {e}")
        
        # === STAGE 1: LUA BYTECODE DETECTION ===
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∏–≥–Ω–∞—Ç—É—Ä—ã Lua 5.1, 5.2, 5.3, Luau
        lua_signatures = [
            b'\x1bLua',  # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π Lua 5.x
            b'\x1bLJ',   # LuaJIT
            b'\x00\x00\x00\x00',  # –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
        ]
        
        # –¢–∞–∫–∂–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω –Ω–∞—á–∞–ª–∞ —Å –Ω—É–ª–µ–≤—ã—Ö –±–∞–π—Ç + –≤–µ—Ä—Å–∏—è
        if content[:4] in lua_signatures or (content[0:1] == b'\x00' and len(content) > 100):
            detection_log.append("üîç Detected Lua Bytecode (compiled)")
            detection_log.append("  ‚ö° Will use unluac decompiler")
            return content, detection_log
        
        # IronBrew —á–∞—Å—Ç–æ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤
        if content[:10].count(b'\x00') > 5 and len(content) > 200:
            detection_log.append("üîç Possible IronBrew bytecode detected")
            # –ü—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ embedded Lua –∫–æ–¥ –ø–æ—Å–ª–µ –º–∞—Ä–∫–µ—Ä–æ–≤
            for marker in [b'return', b'local', b'function']:
                pos = content.find(marker)
                if pos > 0 and pos < 1000:
                    detection_log.append(f"  üìç Found Lua keyword at offset {pos}")
                    break
        
        # === STAGE 2: –ü–æ–ø—ã—Ç–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∫ —Ç–µ–∫—Å—Ç ===
        try:
            text = content.decode('utf-8', 'ignore')
        except:
            try:
                text = content.decode('latin1')
            except:
                detection_log.append("‚ö†Ô∏è Binary content, limited text processing")
                return content, detection_log
        
        original_text = text
        modified = False
        
        # === STAGE 3: HEX ESCAPE SEQUENCES ===
        # –ü–∞—Ç—Ç–µ—Ä–Ω 1: \xNN –≤ —Å—Ç—Ä–æ–∫–∞—Ö
        if '\\x' in text:
            detection_log.append("üîç Found hex escape sequences (\\xNN)")
            
            # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–∫–æ–ª—å–∫–æ –∏—Ö
            hex_count = text.count('\\x')
            detection_log.append(f"  üìä Found {hex_count} hex escapes")
            
            # –î–µ–∫–æ–¥–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã —Å \x
            def decode_hex_string(match):
                try:
                    hex_content = match.group(1)
                    # –ó–∞–º–µ–Ω—è–µ–º \xNN –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–µ –±–∞–π—Ç—ã
                    decoded = bytes.fromhex(hex_content.replace('\\x', ''))
                    # –ü—ã—Ç–∞–µ–º—Å—è –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∫ —Ç–µ–∫—Å—Ç
                    try:
                        result = decoded.decode('utf-8')
                        return f'"{result}"'
                    except:
                        # –ï—Å–ª–∏ –Ω–µ —Ç–µ–∫—Å—Ç, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å –Ω–æ —á–∏—â–µ
                        return f'--[[HEX: {decoded.hex()}]]'
                except:
                    return match.group(0)
            
            # –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è "...\\xNN\\xNN..." —Å—Ç—Ä–æ–∫
            text = re.sub(r'"([^"]*(?:\\x[0-9a-fA-F]{2})+[^"]*)"', decode_hex_string, text)
            
            # –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è '...\\xNN\\xNN...' —Å—Ç—Ä–æ–∫
            text = re.sub(r"'([^']*(?:\\x[0-9a-fA-F]{2})+[^']*)'", decode_hex_string, text)
            
            if text != original_text:
                detection_log.append("  ‚úÖ Decoded hex escape sequences")
                modified = True
        
        # === STAGE 4: BASE64 DETECTION ===
        # –ò—â–µ–º –±–æ–ª—å—à–∏–µ base64 –±–ª–æ–∫–∏ (—Ö–∞—Ä–∞–∫—Ç–µ—Ä–Ω–æ –¥–ª—è MoonSec V3)
        base64_pattern = r'[A-Za-z0-9+/]{100,}={0,2}'
        base64_matches = re.findall(base64_pattern, text)
        
        if base64_matches:
            detection_log.append(f"üîç Found {len(base64_matches)} Base64 blocks")
            
            for i, b64_str in enumerate(base64_matches[:5]):  # –õ–∏–º–∏—Ç 5
                try:
                    decoded = base64.b64decode(b64_str)
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ–ª—É—á–∏–ª–∏
                    if decoded[:4] in lua_signatures:
                        detection_log.append(f"  ‚úÖ Block {i}: Lua bytecode ({len(decoded)} bytes)")
                        return decoded, detection_log
                    elif b'local' in decoded or b'function' in decoded or b'return' in decoded:
                        decoded_text = decoded.decode('utf-8', 'ignore')
                        text = text.replace(b64_str, f'\n--[[BASE64_DECODED_{i}]]--\n{decoded_text}\n')
                        detection_log.append(f"  ‚úÖ Block {i}: Lua source code ({len(decoded)} bytes)")
                        modified = True
                    elif len(decoded) > 100:
                        # –í–æ–∑–º–æ–∂–Ω–æ, —ç—Ç–æ –¥–∞–Ω–Ω—ã–µ - —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
                        detection_log.append(f"  ‚ÑπÔ∏è Block {i}: Binary data ({len(decoded)} bytes)")
                except Exception as e:
                    detection_log.append(f"  ‚ö†Ô∏è Block {i} decode failed: {e}")
        
        # === STAGE 5: ASCII BYTE ARRAYS ===
        # –ü–∞—Ç—Ç–µ—Ä–Ω: {72,101,108,108,111} –∏–ª–∏ string.char(72,101,...)
        
        # –í–∞—Ä–∏–∞–Ω—Ç 1: string.char(...)
        char_pattern = r'string\.char\((\d+(?:\s*,\s*\d+){4,})\)'
        for match in re.finditer(char_pattern, text):
            try:
                numbers = [int(n.strip()) for n in match.group(1).split(',')]
                if all(0 <= n <= 255 for n in numbers):
                    decoded_str = ''.join(chr(n) for n in numbers)
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–∏—Ç–∞–µ–º–æ—Å—Ç—å
                    if len(decoded_str) > 3:
                        text = text.replace(match.group(0), f'"{decoded_str}"')
                        detection_log.append(f"  ‚úÖ Decoded string.char: {decoded_str[:40]}...")
                        modified = True
            except:
                pass
        
        # –í–∞—Ä–∏–∞–Ω—Ç 2: table.concat + char array
        concat_pattern = r'table\.concat\s*\(\s*\{([^}]+)\}\s*\)'
        for match in re.finditer(concat_pattern, text):
            try:
                content_str = match.group(1)
                # –ò—â–µ–º —á–∏—Å–ª–∞
                numbers = re.findall(r'\d+', content_str)
                if len(numbers) > 5:
                    numbers = [int(n) for n in numbers]
                    if all(0 <= n <= 255 for n in numbers):
                        decoded_str = ''.join(chr(n) for n in numbers)
                        text = text.replace(match.group(0), f'"{decoded_str}"')
                        detection_log.append(f"  ‚úÖ Decoded table.concat array: {decoded_str[:40]}...")
                        modified = True
            except:
                pass
        
        # === STAGE 6: HEX STRINGS (pure hex) ===
        # –ü–∞—Ç—Ç–µ—Ä–Ω: "48656c6c6f" (–±–µ–∑ \\x)
        pure_hex_pattern = r'"([0-9a-fA-F]{10,})"'
        for match in re.finditer(pure_hex_pattern, text):
            try:
                hex_str = match.group(1)
                if len(hex_str) % 2 == 0:  # –í–∞–ª–∏–¥–Ω–∞—è –¥–ª–∏–Ω–∞
                    decoded = bytes.fromhex(hex_str)
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ —á–∏—Ç–∞–µ–º–æ—Å—Ç—å
                    try:
                        decoded_text = decoded.decode('utf-8')
                        if all(32 <= ord(c) <= 126 or c in '\n\r\t' for c in decoded_text[:20]):
                            text = text.replace(f'"{hex_str}"', f'"{decoded_text}"')
                            detection_log.append(f"  ‚úÖ Decoded pure hex string: {decoded_text[:40]}...")
                            modified = True
                    except:
                        pass
            except:
                pass
        
        # === STAGE 7: XOR PATTERN DETECTION ===
        xor_patterns = [
            r'bit\.bxor\s*\(',
            r'bit32\.bxor\s*\(',
            r'string\.byte.*bit',
        ]
        
        for pattern in xor_patterns:
            if re.search(pattern, text):
                detection_log.append("üîç Detected XOR encryption pattern")
                break
        
        # === STAGE 8: IRONBREW SPECIFIC PATTERNS ===
        ironbrew_markers = [
            r'Ironbrew',
            r'vmenv',
            r'vm_',
            r'_ENV\s*=\s*\{',
            r'Deserialize',
        ]
        
        for marker in ironbrew_markers:
            if re.search(marker, text, re.IGNORECASE):
                detection_log.append(f"üîç Detected IronBrew marker: {marker}")
                break
        
        # === STAGE 9: MOONSEC V3 SPECIFIC PATTERNS ===
        moonsec_markers = [
            r'MoonSec',
            r'PSU',
            r'Psu',
            r'IllIIl',
            r'l1ll1',
        ]
        
        for marker in moonsec_markers:
            if re.search(marker, text, re.IGNORECASE):
                detection_log.append(f"üîç Detected MoonSec marker: {marker}")
                break
        
        # === STAGE 10: UNICODE ESCAPES ===
        if '\\u' in text:
            unicode_pattern = r'\\u([0-9a-fA-F]{4})'
            
            def unicode_replace(match):
                try:
                    return chr(int(match.group(1), 16))
                except:
                    return match.group(0)
            
            text = re.sub(unicode_pattern, unicode_replace, text)
            if text != original_text:
                detection_log.append("  ‚úÖ Decoded Unicode escapes")
                modified = True
        
        # === STAGE 11: Obfuscated variable names detection ===
        # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–µ –∏–º–µ–Ω–∞
        suspicious_names = re.findall(r'\b(_+[0-9a-fA-F]{6,}|[lI1]{5,}|_+[A-Z]{10,})\b', text)
        if len(suspicious_names) > 10:
            detection_log.append(f"üîç Found {len(suspicious_names)} obfuscated identifiers")
        
        # === FINAL: Return results ===
        if modified:
            final_size = len(text.encode('utf-8'))
            detection_log.append(f"‚ú® Pre-processing complete: {original_size} -> {final_size} bytes")
            return text.encode('utf-8'), detection_log
        
        return content, detection_log

    # ==========================================
    # ENHANCED LUA ENVIRONMENT
    # ==========================================
    
    def _create_lua_environment(self) -> str:
        """–°–æ–∑–¥–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø–æ–ª–Ω—É—é Lua —Å—Ä–µ–¥—É –¥–ª—è IronBrew/MoonSec"""
        
        return """
-- ==========================================
-- ADVANCED DEOBFUSCATION ENVIRONMENT V3.1
-- Supports: IronBrew, MoonSec V3, Custom obfuscators
-- ==========================================

-- Storage
_G.CAPTURED_CHUNKS = {}
_G.DETECTED_STRINGS = {}
_G.ACTION_LOG = {}
_G.FINAL_GLOBALS = {}
_G.DETECTED_KEYS = {}
_G.DECODED_PAYLOADS = {}
_G.LOADSTRING_DEPTH = 0
_G.MAX_LOADSTRING_DEPTH = 15
_G.XOR_OPERATIONS = {}
_G.BYTE_ARRAYS = {}

local function log_action(msg)
    if #_G.ACTION_LOG < 3000 then 
        table.insert(_G.ACTION_LOG, msg) 
    end
end

-- ==========================================
-- DECODERS & UTILITIES
-- ==========================================

-- Base64 decoder
local b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
function _G.base64_decode(data)
    data = string.gsub(data, '[^'..b64chars..'=]', '')
    return (data:gsub('.', function(x)
        if (x == '=') then return '' end
        local r,f='',(b64chars:find(x)-1)
        for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
        return r;
    end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
        if (#x ~= 8) then return '' end
        local c=0
        for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
        return string.char(c)
    end))
end

-- Hex decoder
function _G.hex_decode(str)
    return (str:gsub('..', function(cc)
        return string.char(tonumber(cc, 16))
    end))
end

-- XOR decrypt
function _G.xor_decrypt(data, key)
    local result = {}
    local key_len = #key
    for i = 1, #data do
        local data_byte = data:byte(i)
        local key_byte = key:byte(((i - 1) % key_len) + 1)
        table.insert(result, string.char(bit.bxor(data_byte, key_byte)))
    end
    return table.concat(result)
end

-- ==========================================
-- BITWISE OPERATIONS (FULL IMPLEMENTATION)
-- ==========================================
local bit = {}
function bit.tobit(x) 
    x = x % 4294967296
    if x >= 2147483648 then x = x - 4294967296 end
    return x 
end
function bit.bnot(x) return 4294967295 - x % 4294967296 end

local function bit_oper(a, b, oper)
    local r, m, s = 0, 2^31, nil
    repeat 
        s, a, b = a+b+m, a%m, b%m
        r, m = r + m*oper%(s-a-b), m/2 
    until m < 1
    return r
end

function bit.band(a, b) return bit_oper(a, b, 4) end
function bit.bor(a, b) return bit_oper(a, b, 1) end
function bit.bxor(a, b) return bit_oper(a, b, 3) end
function bit.lshift(a, b) return (a * 2^b) % 4294967296 end
function bit.rshift(a, b) return math.floor(a / 2^b) % 4294967296 end
function bit.arshift(a, b) 
    local z = math.floor(a / 2^b) % 4294967296
    if a >= 2147483648 then z = z + 4294967296 - 2^(32-b) end
    return z
end

-- Aliases –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
function bit.rol(x, n) return bit.lshift(x, n) + bit.rshift(x, 32-n) end
function bit.ror(x, n) return bit.rshift(x, n) + bit.lshift(x, 32-n) end
function bit.bswap(x)
    local a = bit.band(x, 0xff)
    local b = bit.band(bit.rshift(x, 8), 0xff)
    local c = bit.band(bit.rshift(x, 16), 0xff)
    local d = bit.band(bit.rshift(x, 24), 0xff)
    return bit.lshift(a, 24) + bit.lshift(b, 16) + bit.lshift(c, 8) + d
end

package.loaded.bit = bit
package.loaded.bit32 = bit
_G.bit = bit
_G.bit32 = bit

-- ==========================================
-- ROBLOX API EMULATION
-- ==========================================
local function CreateSignal()
    local callbacks = {}
    return {
        Connect = function(self, func)
            table.insert(callbacks, func)
            return {
                Disconnect = function() end,
                Connected = true
            }
        end,
        Fire = function(self, ...)
            for _, f in ipairs(callbacks) do 
                pcall(f, ...) 
            end
        end,
        Wait = function(self)
            return 0
        end
    }
end

_G.Instance = {}
function _G.Instance.new(className, parent)
    local obj = {}
    obj.ClassName = className or "Folder"
    obj.Name = className or "Folder"
    obj.Parent = parent
    obj.Archivable = true
    obj.Changed = CreateSignal()
    obj.ChildAdded = CreateSignal()
    obj.ChildRemoved = CreateSignal()
    obj.DescendantAdded = CreateSignal()
    obj.DescendantRemoving = CreateSignal()
    
    -- Methods
    function obj:Destroy() end
    function obj:Clone() return _G.Instance.new(self.ClassName) end
    function obj:ClearAllChildren() end
    function obj:FindFirstChild(name, recursive) return nil end
    function obj:FindFirstChildOfClass(className) return nil end
    function obj:FindFirstChildWhichIsA(className) return nil end
    function obj:WaitForChild(name, timeout) return _G.Instance.new("Folder", obj) end
    function obj:GetChildren() return {} end
    function obj:GetDescendants() return {} end
    function obj:IsA(className) return self.ClassName == className end
    function obj:IsDescendantOf(ancestor) return false end
    function obj:GetFullName() return self.Name end
    function obj:GetPropertyChangedSignal(prop) return CreateSignal() end
    
    -- –ú–µ—Ç–∞—Ç–∞–±–ª–∏—Ü–∞
    local mt = {
        __index = function(t, k)
            if k == "Value" then return "MockValue" end
            if k == "Text" then return "" end
            if k == "Size" then return 0 end
            return rawget(t, k)
        end,
        __newindex = function(t, k, v)
            rawset(t, k, v)
            if t.Changed then
                pcall(function() t.Changed:Fire(k) end)
            end
        end,
        __tostring = function(t) return t.Name end
    }
    return setmetatable(obj, mt)
end

-- Data types
_G.Vector3 = {}
_G.Vector3.__index = _G.Vector3
function _G.Vector3.new(x, y, z)
    return setmetatable({X=x or 0, Y=y or 0, Z=z or 0}, _G.Vector3)
end
_G.Vector3.zero = _G.Vector3.new(0,0,0)
_G.Vector3.one = _G.Vector3.new(1,1,1)
function _G.Vector3.__add(a, b) return _G.Vector3.new(a.X+b.X, a.Y+b.Y, a.Z+b.Z) end
function _G.Vector3.__sub(a, b) return _G.Vector3.new(a.X-b.X, a.Y-b.Y, a.Z-b.Z) end
function _G.Vector3.__mul(a, b) 
    if type(b) == "number" then return _G.Vector3.new(a.X*b, a.Y*b, a.Z*b) end
    return _G.Vector3.new(a.X*b.X, a.Y*b.Y, a.Z*b.Z)
end
function _G.Vector3.__div(a, b)
    if type(b) == "number" then return _G.Vector3.new(a.X/b, a.Y/b, a.Z/b) end
    return _G.Vector3.new(a.X/b.X, a.Y/b.Y, a.Z/b.Z)
end

_G.Vector2 = {}
_G.Vector2.__index = _G.Vector2
function _G.Vector2.new(x, y)
    return setmetatable({X=x or 0, Y=y or 0}, _G.Vector2)
end

_G.CFrame = {}
_G.CFrame.__index = _G.CFrame
function _G.CFrame.new(...)
    return setmetatable({p=_G.Vector3.new(...)}, _G.CFrame)
end
function _G.CFrame.Angles(...)
    return _G.CFrame.new()
end
function _G.CFrame.fromEulerAnglesXYZ(...)
    return _G.CFrame.new()
end
function _G.CFrame:GetComponents()
    return 0,0,0,1,0,0,0,1,0,0,0,1
end

_G.UDim2 = {}
function _G.UDim2.new(xs, xo, ys, yo)
    return {X={Scale=xs or 0, Offset=xo or 0}, Y={Scale=ys or 0, Offset=yo or 0}}
end
function _G.UDim2.fromScale(x, y)
    return _G.UDim2.new(x, 0, y, 0)
end
function _G.UDim2.fromOffset(x, y)
    return _G.UDim2.new(0, x, 0, y)
end

_G.Color3 = {}
function _G.Color3.new(r, g, b)
    return {R=r or 0, G=g or 0, B=b or 0}
end
function _G.Color3.fromRGB(r, g, b)
    return _G.Color3.new((r or 0)/255, (g or 0)/255, (b or 0)/255)
end
function _G.Color3.fromHSV(h, s, v)
    return _G.Color3.new(v, v, v)
end

_G.Enum = setmetatable({}, {
    __index = function(t, k)
        return setmetatable({}, {
            __index = function(t2, k2)
                return {Name=k2, Value=1, EnumType=k}
            end
        })
    end
})

-- Task library
_G.task = {
    wait = function(t) return t or 0 end,
    spawn = function(f) pcall(f) return end,
    delay = function(t, f) pcall(f) return end,
    defer = function(f) pcall(f) return end,
    desynchronize = function() end,
    synchronize = function() end
}
_G.wait = _G.task.wait
_G.spawn = _G.task.spawn
_G.delay = _G.task.delay

-- Math extensions
math.clamp = function(x, min, max)
    return math.max(min, math.min(max, x))
end
math.sign = function(x)
    return x > 0 and 1 or (x < 0 and -1 or 0)
end
math.round = function(x)
    return math.floor(x + 0.5)
end

-- Table extensions
function table.find(t, value)
    for i, v in ipairs(t) do
        if v == value then return i end
    end
    return nil
end

function table.pack(...)
    return {n=select('#',...), ...}
end

function table.unpack(t, i, j)
    return unpack(t, i or 1, j or t.n or #t)
end

function table.move(a1, f, e, t, a2)
    a2 = a2 or a1
    for i = f, e do
        a2[t] = a1[i]
        t = t + 1
    end
    return a2
end

function table.create(count, value)
    local t = {}
    for i = 1, count do
        t[i] = value
    end
    return t
end

function table.clear(t)
    for k in pairs(t) do
        t[k] = nil
    end
end

-- String extensions
function string.split(str, delimiter)
    local result = {}
    local pattern = string.format("([^%s]+)", delimiter)
    for match in string.gmatch(str, pattern) do
        table.insert(result, match)
    end
    return result
end

-- Game hierarchy
_G.game = _G.Instance.new("DataModel")
_G.game.Name = "Game"

-- Players
_G.game.Players = _G.Instance.new("Players", _G.game)
_G.game.Players.LocalPlayer = _G.Instance.new("Player", _G.game.Players)
_G.game.Players.LocalPlayer.Name = "DeobfuscatorUser"
_G.game.Players.LocalPlayer.UserId = 2652366
_G.game.Players.LocalPlayer.Character = _G.Instance.new("Model")
_G.game.Players.LocalPlayer.Character.Name = "DeobfuscatorUser"
_G.game.Players.LocalPlayer.Character.Parent = nil

local humanoid = _G.Instance.new("Humanoid", _G.game.Players.LocalPlayer.Character)
local hrp = _G.Instance.new("Part", _G.game.Players.LocalPlayer.Character)
hrp.Name = "HumanoidRootPart"

function _G.game.Players:GetPlayers() return {_G.game.Players.LocalPlayer} end

-- Services
_G.game.Workspace = _G.Instance.new("Workspace", _G.game)
_G.workspace = _G.game.Workspace

_G.game.Lighting = _G.Instance.new("Lighting", _G.game)
_G.game.ReplicatedStorage = _G.Instance.new("ReplicatedStorage", _G.game)
_G.game.ReplicatedFirst = _G.Instance.new("ReplicatedFirst", _G.game)
_G.game.ServerStorage = _G.Instance.new("ServerStorage", _G.game)
_G.game.ServerScriptService = _G.Instance.new("ServerScriptService", _G.game)
_G.game.StarterGui = _G.Instance.new("StarterGui", _G.game)
_G.game.StarterPack = _G.Instance.new("StarterPack", _G.game)
_G.game.StarterPlayer = _G.Instance.new("StarterPlayer", _G.game)
_G.game.Teams = _G.Instance.new("Teams", _G.game)
_G.game.SoundService = _G.Instance.new("SoundService", _G.game)
_G.game.Chat = _G.Instance.new("Chat", _G.game)
_G.game.LocalizationService = _G.Instance.new("LocalizationService", _G.game)
_G.game.TestService = _G.Instance.new("TestService", _G.game)

-- RunService
_G.game.RunService = _G.Instance.new("RunService", _G.game)
_G.game.RunService.RenderStepped = CreateSignal()
_G.game.RunService.Heartbeat = CreateSignal()
_G.game.RunService.Stepped = CreateSignal()
function _G.game.RunService:IsClient() return true end
function _G.game.RunService:IsServer() return false end
function _G.game.RunService:IsStudio() return false end

-- HttpService
_G.game.HttpService = _G.Instance.new("HttpService", _G.game)
_G.game.HttpService.HttpEnabled = true

function _G.game.HttpService:JSONEncode(t)
    -- –ü—Ä–æ—Å—Ç–∞—è JSON-—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è
    if type(t) == "table" then
        local result = {}
        for k, v in pairs(t) do
            table.insert(result, string.format('"%s":%s', tostring(k), 
                type(v) == "string" and string.format('"%s"', v) or tostring(v)))
        end
        return "{" .. table.concat(result, ",") .. "}"
    end
    return tostring(t)
end

function _G.game.HttpService:JSONDecode(s)
    -- –ó–∞–≥–ª—É—à–∫–∞
    return {}
end

function _G.game.HttpService:GetAsync(url, nocache)
    return _G.game:HttpGet(url)
end

function _G.game.HttpService:PostAsync(url, data, contenttype, compress)
    return _G.game:HttpPost(url, data)
end

function _G.game.HttpService:GenerateGUID(wrapInCurlyBraces)
    local template = wrapInCurlyBraces and '{xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx}' 
                                        or 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
    return string.gsub(template, '[xy]', function(c)
        local v = (c == 'x') and math.random(0, 0xf) or math.random(8, 0xb)
        return string.format('%x', v)
    end)
end

-- UserInputService
_G.game.UserInputService = _G.Instance.new("UserInputService", _G.game)
_G.game.UserInputService.InputBegan = CreateSignal()
_G.game.UserInputService.InputEnded = CreateSignal()
_G.game.UserInputService.InputChanged = CreateSignal()

-- TweenService
_G.game.TweenService = _G.Instance.new("TweenService", _G.game)
function _G.game.TweenService:Create(instance, tweenInfo, propertyTable)
    return {
        Play = function() end,
        Pause = function() end,
        Cancel = function() end,
        PlaybackState = "Completed",
        Completed = CreateSignal()
    }
end

-- MarketplaceService
_G.game.MarketplaceService = _G.Instance.new("MarketplaceService", _G.game)
function _G.game.MarketplaceService:GetProductInfo(assetId, infoType)
    return {
        Name = "MockAsset",
        Description = "",
        AssetId = assetId,
        AssetTypeId = 0,
        Creator = {Name = "Unknown", Id = 0}
    }
end

-- GetService method
function _G.game:GetService(serviceName)
    if self[serviceName] then
        return self[serviceName]
    end
    local service = _G.Instance.new(serviceName, self)
    self[serviceName] = service
    return service
end

function _G.game:FindService(serviceName)
    return self[serviceName]
end

_G.script = _G.Instance.new("Script", _G.workspace)
_G.script.Name = "DeobfuscatorScript"

-- ==========================================
-- NETWORK EMULATION
-- ==========================================
local function handle_http_response(url, content)
    if content and #content > 0 then
        log_action("   ‚úÖ HTTP 200: " .. #content .. " bytes")
        
        if #content > 50 then
            table.insert(_G.CAPTURED_CHUNKS, {
                data = content,
                size = #content,
                type = "http_response",
                url = url
            })
            table.insert(_G.DETECTED_STRINGS, "HTTP_URL: " .. url)
            
            -- Auto-decode attempts
            pcall(function()
                local decoded = base64_decode(content)
                if decoded and #decoded > 10 then
                    log_action("   üîì Auto-decoded Base64 from HTTP")
                    table.insert(_G.DECODED_PAYLOADS, {source="http_base64", data=decoded})
                end
            end)
            
            pcall(function()
                if content:match("^[0-9a-fA-F]+$") and #content % 2 == 0 then
                    local decoded = hex_decode(content)
                    if #decoded > 10 then
                        log_action("   üîì Auto-decoded Hex from HTTP")
                        table.insert(_G.DECODED_PAYLOADS, {source="http_hex", data=decoded})
                    end
                end
            end)
        end
        return content
    else
        log_action("   ‚ùå HTTP Error/Empty")
        return ""
    end
end

function _G.game:HttpGet(url)
    log_action("üåç HTTP GET: " .. tostring(url))
    local success, res = pcall(PYTHON_HTTP_GET, url)
    if success and res then
        return handle_http_response(url, res)
    end
    return ""
end

function _G.game:HttpGetAsync(url)
    return self:HttpGet(url)
end

function _G.game:HttpPost(url, data)
    log_action("üåç HTTP POST: " .. tostring(url))
    return "ProxyResponse"
end

function _G.game:HttpPostAsync(url, data, contentType)
    return self:HttpPost(url, data)
end

-- Request emulation
local function emulate_request(options)
    local url = options.Url or options.url
    if not url then return {Success=false, StatusCode=400} end
    
    log_action("üåç REQUEST: " .. tostring(url))
    local body = _G.game:HttpGet(url)
    
    return {
        Body = body,
        StatusCode = (body ~= "") and 200 or 404,
        Success = (body ~= ""),
        StatusMessage = (body ~= "") and "OK" or "Not Found",
        Headers = {}
    }
end

_G.request = emulate_request
_G.http_request = emulate_request
_G.http = {request = emulate_request}

-- ==========================================
-- EXPLOIT ENVIRONMENT
-- ==========================================
_G.syn = {
    request = emulate_request,
    protect_gui = function(obj) return obj end,
    unprotect_gui = function(obj) return obj end,
    is_cached = function(url) return false end,
    cache_replace = function(url, data) end,
    cache_invalidate = function(url) end,
    set_thread_identity = function(n) end,
    get_thread_identity = function() return 2 end,
    queue_on_teleport = function(code) end,
    crypt = {
        encrypt = function(data, key) return data end,
        decrypt = function(data, key) return data end,
        base64_encode = function(data) return "" end,
        base64_decode = function(data) return base64_decode(data) end,
        hash = function(data) return "" end
    },
    websocket = {
        connect = function(url) return {} end
    }
}

-- Executor identification
_G.identifyexecutor = function() return "Synapse X", "2.23.0" end
_G.getexecutorname = function() return "Synapse X" end
_G.is_synapse_function = function(f) return false end
_G.isexecutorclosure = function(f) return false end

-- Environment functions
_G.getgenv = function() return _G end
_G.getrenv = function() return _G end
_G.getreg = function() return {} end
_G.getgc = function(includeTables) return {} end
_G.getinstances = function() return {_G.game} end
_G.getnilinstances = function() return {} end
_G.getscripts = function() return {_G.script} end
_G.getloadedmodules = function() return {} end
_G.getconnections = function(signal) return {} end

-- Metatable functions
_G.getrawmetatable = getmetatable
_G.setrawmetatable = setmetatable
_G.setreadonly = function(t, v) return t end
_G.isreadonly = function(t) return false end

-- Function hooks
_G.checkcaller = function() return true end
_G.islclosure = function(f) return type(f) == "function" end
_G.iscclosure = function(f) return false end
_G.newcclosure = function(f) return f end
_G.hookfunction = function(old, new) return old end
_G.hookmetamethod = function(obj, method, hook) return function() end end
_G.restorefunction = function(f) return f end

-- Debug library extensions
if not debug.getinfo then
    debug.getinfo = function(f, what)
        return {
            source = "script",
            short_src = "script",
            func = f,
            what = "Lua",
            currentline = -1,
            name = "unknown",
            nups = 0,
            nparams = 0,
            isvararg = true
        }
    end
end

if not debug.getupvalue then
    debug.getupvalue = function(f, index) return "upvalue", nil end
end

if not debug.setupvalue then
    debug.setupvalue = function(f, index, value) return "upvalue" end
end

if not debug.getupvalues then
    debug.getupvalues = function(f) return {} end
end

if not debug.getconstants then
    debug.getconstants = function(f) return {} end
end

if not debug.getconstant then
    debug.getconstant = function(f, index) return nil end
end

if not debug.setconstant then
    debug.setconstant = function(f, index, value) end
end

if not debug.getprotos then
    debug.getprotos = function(f) return {} end
end

if not debug.getproto then
    debug.getproto = function(f, index) return function() end end
end

if not debug.getstack then
    debug.getstack = function(level) return {} end
end

-- Filesystem stubs
_G.writefile = function(path, data) 
    log_action("üíæ writefile: " .. tostring(path) .. " (" .. #tostring(data) .. " bytes)")
end
_G.readfile = function(path) 
    log_action("üìÇ readfile: " .. tostring(path))
    return "" 
end
_G.appendfile = function(path, data)
    log_action("‚ûï appendfile: " .. tostring(path))
end
_G.isfile = function(path) return false end
_G.isfolder = function(path) return false end
_G.delfile = function(path) 
    log_action("üóëÔ∏è delfile: " .. tostring(path))
end
_G.delfolder = function(path)
    log_action("üóëÔ∏è delfolder: " .. tostring(path))
end
_G.makefolder = function(path) 
    log_action("üìÅ makefolder: " .. tostring(path))
end
_G.listfiles = function(path) return {} end

-- Clipboard
_G.setclipboard = function(data)
    log_action("üìã setclipboard: " .. tostring(data):sub(1, 50))
end

-- Script execution
_G.loadfile = function(path)
    return function() end
end
_G.dofile = function(path)
    return nil
end

-- ==========================================
-- ENHANCED SPYWARE HOOKS
-- ==========================================
local function capture_string(s)
    if type(s) == "string" and #s > 3 then
        -- –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –º—É—Å–æ—Ä
        if not s:find("stack begin") 
           and not s:find("upvalue") 
           and not s:match("^%s*$")
           and not s:find("^%[")
           and not s:find("^<") then
            _G.DETECTED_STRINGS[s] = true
        end
    end
    return s
end

-- Hook string.char (–¥–µ—Ç–µ–∫—Ü–∏—è –º–∞—Å—Å–æ–≤–æ–π –¥–µ—à–∏—Ñ—Ä–æ–≤–∫–∏)
local real_char = string.char
string.char = function(...)
    local args = {...}
    if #args > 5 then
        local res = real_char(...)
        capture_string(res)
        
        -- –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ XOR –∫–ª—é—á–∏
        if #args >= 10 and #args <= 100 then
            local key_str = table.concat(args, ",")
            if not _G.DETECTED_KEYS[key_str] then
                _G.DETECTED_KEYS[key_str] = true
                table.insert(_G.DETECTED_KEYS, key_str)
            end
        end
        
        return res
    end
    return real_char(...)
end

-- Hook table.concat
local real_concat = table.concat
table.concat = function(t, sep, i, j)
    local res = real_concat(t, sep, i, j)
    capture_string(res)
    
    -- –ï—Å–ª–∏ —ç—Ç–æ –º–∞—Å—Å–∏–≤ —á–∏—Å–µ–ª, —Å–æ—Ö—Ä–∞–Ω—è–µ–º
    if type(t) == "table" and #t > 5 then
        local is_byte_array = true
        for idx = 1, math.min(#t, 10) do
            if type(t[idx]) ~= "number" or t[idx] < 0 or t[idx] > 255 then
                is_byte_array = false
                break
            end
        end
        
        if is_byte_array then
            table.insert(_G.BYTE_ARRAYS, {data=t, result=res})
        end
    end
    
    return res
end

-- Hook string.byte (XOR detection)
local real_byte = string.byte
string.byte = function(s, i, j)
    -- –î–µ—Ç–µ–∫—Ç–∏—Ä—É–µ–º —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–ª—é—á–∞
    if type(s) == "string" and #s > 10 and not i and not j then
        local sample = s:sub(1, 30)
        log_action("üîë Possible key scan: " .. sample)
    end
    return real_byte(s, i, j)
end

-- Hook string.sub (—á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –æ–±—Ñ—É—Å–∫–∞—Ç–æ—Ä–∞—Ö)
local real_sub = string.sub
string.sub = function(s, i, j)
    local res = real_sub(s, i, j)
    -- –ï—Å–ª–∏ —ç–∫—Å—Ç—Ä–∞–∫—Ç–∏–º –±–æ–ª—å—à–æ–π –∫—É—Å–æ–∫
    if type(s) == "string" and #s > 1000 and #res > 100 then
        capture_string(res)
    end
    return res
end

-- Hook string.gsub (–ø–∞—Ç—Ç–µ—Ä–Ω—ã –∑–∞–º–µ–Ω—ã)
local real_gsub = string.gsub
string.gsub = function(s, pattern, repl, n)
    local res, count = real_gsub(s, pattern, repl, n)
    if count and count > 10 then
        log_action("üîÑ Mass string.gsub: " .. count .. " replacements")
        capture_string(res)
    end
    return res, count
end

-- Hook bit.bxor (XOR operations tracking)
local real_bxor = bit.bxor
bit.bxor = function(a, b)
    -- –õ–æ–≥–∏—Ä—É–µ–º —á–∞—Å—Ç—ã–µ XOR –æ–ø–µ—Ä–∞—Ü–∏–∏
    if type(a) == "number" and type(b) == "number" then
        local key = a .. "^" .. b
        _G.XOR_OPERATIONS[key] = (_G.XOR_OPERATIONS[key] or 0) + 1
        
        -- –ï—Å–ª–∏ –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ –∑–Ω–∞—á–µ–Ω–∏–µ XOR–∏—Ç—Å—è –º–Ω–æ–≥–æ —Ä–∞–∑
        if _G.XOR_OPERATIONS[key] == 10 then
            log_action("üîê Frequent XOR: " .. a .. " ^ " .. b)
        end
    end
    return real_bxor(a, b)
end

-- CRITICAL: Recursive loadstring hook
local real_load = load
local function hooked_load(chunk, chunkname, mode, env)
    _G.LOADSTRING_DEPTH = _G.LOADSTRING_DEPTH + 1
    
    -- –ó–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–π —Ä–µ–∫—É—Ä—Å–∏–∏
    if _G.LOADSTRING_DEPTH > _G.MAX_LOADSTRING_DEPTH then
        log_action("‚ö†Ô∏è Max loadstring depth " .. _G.MAX_LOADSTRING_DEPTH .. " reached!")
        _G.LOADSTRING_DEPTH = _G.LOADSTRING_DEPTH - 1
        return function() end
    end
    
    if type(chunk) == "string" and #chunk > 40 then
        local chunk_id = "chunk_" .. #_G.CAPTURED_CHUNKS
        
        table.insert(_G.CAPTURED_CHUNKS, {
            data = chunk,
            size = #chunk,
            type = "loadstring",
            depth = _G.LOADSTRING_DEPTH,
            id = chunk_id
        })
        
        log_action("üî• [Depth " .. _G.LOADSTRING_DEPTH .. "] Captured " .. chunk_id .. ": " .. #chunk .. " bytes")
        
        -- –ü—Ä–æ–±—É–µ–º –≤—ã–ø–æ–ª–Ω–∏—Ç—å –¥–ª—è —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∏ —Å–ª–µ–¥—É—é—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
        local success, func = pcall(real_load, chunk, chunkname, mode, env or _G)
        if success and type(func) == "function" then
            pcall(func)
        end
    end
    
    _G.LOADSTRING_DEPTH = _G.LOADSTRING_DEPTH - 1
    return real_load(chunk, chunkname, mode, env)
end

_G.load = hooked_load
_G.loadstring = hooked_load

-- –¢–∞–∫–∂–µ —Ö—É–∫–∞–µ–º require (–º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏)
local real_require = require
function _G.require(module)
    log_action("üì¶ require: " .. tostring(module))
    return real_require(module)
end

-- ==========================================
-- GLOBAL DUMP
-- ==========================================
function _G.dump_globals()
    local ignore = {
        -- Standard Lua
        string=1, math=1, table=1, bit=1, bit32=1, pairs=1, ipairs=1, next=1, _G=1,
        package=1, os=1, io=1, debug=1, coroutine=1, print=1, warn=1, error=1,
        tostring=1, tonumber=1, type=1, pcall=1, xpcall=1, select=1, unpack=1,
        setmetatable=1, getmetatable=1, rawget=1, rawset=1, rawequal=1, rawlen=1,
        collectgarbage=1, gcinfo=1, newproxy=1, assert=1, getfenv=1, setfenv=1,
        
        -- Roblox
        Instance=1, Vector3=1, Vector2=1, CFrame=1, UDim2=1, Color3=1, Enum=1,
        task=1, wait=1, spawn=1, delay=1, defer=1, game=1, workspace=1, script=1,
        
        -- Exploit
        getgenv=1, getrenv=1, getreg=1, getgc=1, checkcaller=1, islclosure=1,
        iscclosure=1, newcclosure=1, hookfunction=1, hookmetamethod=1,
        identifyexecutor=1, getexecutorname=1, syn=1, request=1, http_request=1,
        http=1, writefile=1, readfile=1, appendfile=1, isfile=1, isfolder=1,
        delfile=1, delfolder=1, makefolder=1, listfiles=1, setclipboard=1,
        loadfile=1, dofile=1, getrawmetatable=1, setrawmetatable=1, setreadonly=1,
        isreadonly=1, getinstances=1, getnilinstances=1, getscripts=1,
        getloadedmodules=1, getconnections=1, isexecutorclosure=1,
        is_synapse_function=1, restorefunction=1,
        
        -- Internal
        PYTHON_HTTP_GET=1, DETECTED_STRINGS=1, CAPTURED_CHUNKS=1, ACTION_LOG=1,
        FINAL_GLOBALS=1, LOADSTRING_DEPTH=1, MAX_LOADSTRING_DEPTH=1,
        DETECTED_KEYS=1, DECODED_PAYLOADS=1, XOR_OPERATIONS=1, BYTE_ARRAYS=1,
        base64_decode=1, hex_decode=1, xor_decrypt=1, dump_globals=1,
        require=1, load=1, loadstring=1
    }
    
    for k, v in pairs(getfenv()) do
        if not ignore[k] then
            local vtype = type(v)
            if vtype == "string" or vtype == "number" or vtype == "boolean" then
                table.insert(_G.FINAL_GLOBALS, tostring(k) .. " = " .. tostring(v))
            elseif vtype == "function" then
                table.insert(_G.FINAL_GLOBALS, tostring(k) .. " = <function>")
            elseif vtype == "table" then
                table.insert(_G.FINAL_GLOBALS, tostring(k) .. " = <table>")
            end
        end
    end
end

-- Initial log
log_action("üöÄ Deobfuscation environment initialized")
log_action("üìä Loaded modules: bit, bit32, Roblox API, Exploit env")
"""

    def process(self, content, status_callback=None):
        def update_status(msg):
            if status_callback: status_callback(msg)
            logger.info(f"[STATUS] {msg}")

        if not self._check_java():
            return b"-- [FATAL] Java is missing. Install Java to use unluac."

        # === STAGE 1: PRE-PROCESSING ===
        update_status("üî¨ Multi-layer analysis & decoding...")
        decoded_content, detection_log = self._detect_and_decode(content)
        
        for log_entry in detection_log:
            update_status(log_entry)

        update_status("üß† Initializing Roblox environment (V3.1 Enhanced)...")

        # === STAGE 2: LUA VM SETUP ===
        try:
            lua = LuaRuntime(unpack_returned_tuples=True, encoding=None)
        except Exception as e:
            return f"-- [FATAL] Lua start error: {e}".encode('utf-8')

        # HTTP Bridge
        def py_http_get(url):
            try:
                url = str(url).strip()
                
                # Whitelist
                allowed_domains = [
                    'pastebin.com', 'raw.githubusercontent.com', 'github.com',
                    'rentry.co', 'hastebin.com', 'paste.ee', 'privatebin.net'
                ]
                
                if not any(domain in url for domain in allowed_domains):
                    logger.warning(f"Blocked URL (not whitelisted): {url}")
                    return ""
                
                # Cache
                url_hash = hashlib.md5(url.encode()).hexdigest()
                if url_hash in self.http_cache:
                    update_status(f"üíæ Cache hit: {url[:50]}...")
                    return self.http_cache[url_hash]
                
                headers = {
                    "User-Agent": "Roblox/WinInet",
                    "Accept": "*/*"
                }
                
                update_status(f"üåê GET: {url[:60]}...")
                response = requests.get(url, headers=headers, timeout=15, allow_redirects=True)
                
                if response.status_code == 200:
                    content = response.text[:1000000]  # Max 1MB
                    self.http_cache[url_hash] = content
                    return content
                
                logger.warning(f"HTTP {response.status_code}: {url}")
                return ""
            except Exception as e:
                logger.error(f"HTTP Error: {e}")
                return ""

        lua.globals().PYTHON_HTTP_GET = py_http_get

        # === STAGE 3: EXECUTION ===
        try:
            update_status("üå™Ô∏è Running with full instrumentation...")
            
            lua_env = self._create_lua_environment()
            lua.execute(lua_env)
            
            runner = lua.eval("""
                function(code)
                    local status, err = pcall(function()
                        local f, load_err = load(code, "deobfuscator", "t", _G)
                        if not f then 
                            error("Load error: " .. tostring(load_err))
                        end
                        f()
                    end)
                    
                    if not status then
                        table.insert(_G.ACTION_LOG, "‚ùå Runtime error: " .. tostring(err))
                    end
                    
                    -- Dump final state
                    pcall(_G.dump_globals)
                    return status
                end
            """)
            
            success = runner(decoded_content)
            
            if not success:
                update_status("‚ö†Ô∏è Script execution had errors (check logs)")

            # === STAGE 4: COLLECT RESULTS ===
            update_status("üì¶ Collecting captured data...")
            
            # Strings
            strings_tbl = lua.globals().DETECTED_STRINGS
            detected_strings = []
            if strings_tbl:
                try:
                    for k in strings_tbl:
                        detected_strings.append(str(k))
                except:
                    pass
            
            # Globals
            global_dump = []
            try:
                global_dump = list(lua.globals().FINAL_GLOBALS)
            except:
                pass
            
            # Logs
            action_log = []
            try:
                action_log = list(lua.globals().ACTION_LOG)
            except:
                pass
            
            # Keys
            detected_keys = []
            try:
                keys_tbl = lua.globals().DETECTED_KEYS
                if keys_tbl:
                    for i in range(1, min(len(keys_tbl) + 1, 21)):
                        detected_keys.append(str(keys_tbl[i]))
            except:
                pass
            
            # Chunks
            chunks = []
            try:
                chunks_tbl = lua.globals().CAPTURED_CHUNKS
                if chunks_tbl:
                    for i in range(1, len(chunks_tbl) + 1):
                        c = chunks_tbl[i]
                        chunks.append({
                            'data': c.data,
                            'size': c.size,
                            'type': c.type,
                            'depth': getattr(c, 'depth', 0)
                        })
            except Exception as e:
                logger.warning(f"Error collecting chunks: {e}")
            
            # Decoded payloads
            decoded_payloads = []
            try:
                payloads_tbl = lua.globals().DECODED_PAYLOADS
                if payloads_tbl:
                    for i in range(1, len(payloads_tbl) + 1):
                        p = payloads_tbl[i]
                        decoded_payloads.append({
                            'source': p.source,
                            'data': p.data
                        })
            except:
                pass
            
            # XOR operations
            xor_ops = []
            try:
                xor_tbl = lua.globals().XOR_OPERATIONS
                if xor_tbl:
                    for k, v in xor_tbl.items():
                        if v > 5:  # –¢–æ–ª—å–∫–æ —á–∞—Å—Ç—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
                            xor_ops.append(f"{k} (x{v})")
            except:
                pass
            
            update_status(f"üìä Captured: {len(chunks)} chunks, {len(detected_strings)} strings")
            
            # === STAGE 5: FIND BEST CHUNK ===
            best_chunk = None
            max_score = 0
            chunk_source = "original"
            
            # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 1: Decoded payloads
            for payload in decoded_payloads:
                score = len(str(payload['data'])) * 2
                if score > max_score:
                    max_score = score
                    best_chunk = payload['data']
                    chunk_source = f"auto_decoded_{payload['source']}"
            
            # –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç 2: Loadstring chunks (—Å —É—á–µ—Ç–æ–º –≥–ª—É–±–∏–Ω—ã)
            for chunk in chunks:
                score = chunk['size']
                
                if chunk['type'] == 'loadstring':
                    score *= (1.5 + chunk['depth'] * 0.3)
                elif chunk['type'] == 'http_response':
                    score *= 1.4
                
                if score > max_score:
                    max_score = score
                    best_chunk = chunk['data']
                    chunk_source = f"{chunk['type']}_depth{chunk['depth']}"
            
            target_code = best_chunk if best_chunk else decoded_content
            
            if best_chunk:
                update_status(f"üéØ Using best chunk: {chunk_source} ({len(str(best_chunk))} bytes)")
            else:
                update_status("üìÑ Using original/pre-processed code")

            return self._finalize_output(
                target_code,
                detected_strings,
                global_dump,
                action_log,
                detected_keys,
                detection_log,
                xor_ops,
                update_status
            )

        except Exception as e:
            logger.error(f"Engine crash: {e}", exc_info=True)
            return f"-- [CRASH ERROR]: {str(e)}\n-- Check logs for details".encode('utf-8')

    def _check_java(self):
        try:
            result = subprocess.run(
                ["java", "-version"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                timeout=5
            )
            return result.returncode == 0
        except:
            return False

    def _clean_string(self, s):
        if isinstance(s, bytes):
            try:
                return s.decode('utf-8')
            except:
                try:
                    return s.decode('latin1')
                except:
                    return repr(s)
        return str(s)

    def _finalize_output(self, code_bytes, strings, globals_dump, logs, keys, pre_log, xor_ops, callback):
        if callback: callback("üß¨ Finalizing output...")
        
        # Normalize code_bytes
        if isinstance(code_bytes, str):
            # Check for escaped hex sequences
            if '\\x' in code_bytes[:200]:
                try:
                    code_bytes = code_bytes.encode('utf-8').decode('unicode_escape').encode('latin1')
                    if callback: callback("üîì Decoded embedded escape sequences")
                except:
                    code_bytes = code_bytes.encode('utf-8', 'ignore')
            else:
                code_bytes = code_bytes.encode('utf-8', 'ignore')
        elif not isinstance(code_bytes, bytes):
            code_bytes = str(code_bytes).encode('utf-8', 'ignore')

        # Try decompilation
        decompiled = self._try_decompile(code_bytes)
        
        # Build output
        final_text = "-- " + "="*70 + "\n"
        final_text += "-- ROBLOX DEOBFUSCATOR V3.1 - IRONBREW & MOONSEC EDITION\n"
        final_text += "-- " + "="*70 + "\n\n"
        
        # Pre-processing results
        if pre_log:
            final_text += "-- [[ PRE-PROCESSING ANALYSIS ]] --\n"
            for entry in pre_log:
                final_text += f"-- {entry}\n"
            final_text += "\n"
        
        # XOR operations
        if xor_ops:
            final_text += "-- [[ DETECTED XOR OPERATIONS ]] --\n"
            for op in xor_ops[:20]:
                final_text += f"-- {op}\n"
            final_text += "\n"
        
        # Encryption keys
        if keys:
            final_text += "-- [[ DETECTED ENCRYPTION KEYS ]] --\n"
            for key in keys[:15]:
                clean_key = self._clean_string(key)[:100]
                final_text += f"-- {clean_key}\n"
            final_text += "\n"
        
        # Strings
        final_text += "-- [[ DUMPED STRINGS ]] --\n"
        sorted_strings = sorted(strings, key=lambda x: len(str(x)), reverse=True)
        seen = set()
        for s in sorted_strings[:150]:
            clean = self._clean_string(s).replace('\n', '\\n').replace('\r', '\\r')
            if len(clean) > 3 and clean not in seen:
                final_text += f'-- "{clean[:200]}"\n'
                seen.add(clean)
        
        # Globals
        if globals_dump:
            final_text += "\n-- [[ GLOBAL VARIABLES ]] --\n"
            for g in globals_dump[:100]:
                final_text += f"-- {self._clean_string(g)}\n"
        
        # Execution log
        if logs:
            final_text += "\n-- [[ EXECUTION LOG ]] --\n"
            # Show first 10 and last 40
            shown_logs = logs[:10] + (["-- ... (" + str(len(logs) - 50) + " entries hidden) ..."] if len(logs) > 50 else []) + logs[-40:]
            for l in shown_logs:
                final_text += f"-- {self._clean_string(l)[:200]}\n"
        
        final_text += "\n" + "-- " + "="*70 + "\n"
        final_text += "-- DECOMPILED SOURCE CODE\n"
        final_text += "-- " + "="*70 + "\n\n"
        
        if decompiled:
            try:
                src = decompiled.decode('utf-8', 'ignore')
            except:
                src = decompiled.decode('latin1', 'ignore')
            final_text += self._beautify_lua(src)
        else:
            # Check if it's already readable Lua
            try:
                test_decode = code_bytes.decode('utf-8')
                if any(keyword in test_decode for keyword in ['local ', 'function ', 'return ', 'end']):
                    final_text += "-- [INFO] Source is already in readable form\n\n"
                    final_text += self._beautify_lua(test_decode)
                else:
                    final_text += "-- [WARNING] Could not decompile bytecode\n"
                    final_text += "-- [INFO] Showing hex dump:\n\n"
                    hex_dump = binascii.hexlify(code_bytes[:1000]).decode()
                    for i in range(0, len(hex_dump), 64):
                        final_text += f"-- {hex_dump[i:i+64]}\n"
                    if len(code_bytes) > 1000:
                        final_text += f"-- ... ({len(code_bytes) - 1000} more bytes)\n"
            except:
                final_text += "-- [ERROR] Binary data, cannot display\n"
                final_text += f"-- Size: {len(code_bytes)} bytes\n"

        return final_text.encode('utf-8')

    def _try_decompile(self, bytecode):
        # Skip if it looks like text
        try:
            test = bytecode.decode('utf-8')
            if any(kw in test for kw in ['local ', 'function ', 'return ']):
                return None
        except:
            pass
        
        if not os.path.exists(self.unluac_path):
            logger.warning("unluac.jar not found")
            return None
        
        try:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".luac", mode='wb') as tmp:
                tmp.write(bytecode)
                path = tmp.name
            
            result = subprocess.run(
                ["java", "-Xmx2G", "-jar", self.unluac_path, path],
                capture_output=True,
                timeout=20
            )
            
            os.remove(path)
            
            if result.returncode == 0 and len(result.stdout) > 0:
                return result.stdout
            
            if result.stderr:
                logger.warning(f"unluac error: {result.stderr.decode('utf-8', 'ignore')[:200]}")
            
            return None
        except Exception as e:
            logger.error(f"Decompilation error: {e}")
            return None

    def _beautify_lua(self, source_code):
        # Basic formatting
        source_code = re.sub(r'(\s)(local|return|if|for|while|repeat|function|until|break)(\s)', 
                             r'\n\2 ', source_code)
        
        replacements = {
            " then ": " then\n    ",
            " do ": " do\n    ",
            " else ": "\nelse\n    ",
            " elseif ": "\nelseif ",
            " end": "\nend",
            " repeat ": "\nrepeat\n    ",
            " until ": "\nuntil ",
            ";": ";\n"
        }
        
        for old, new in replacements.items():
            source_code = source_code.replace(old, new)
        
        # Clean up excessive newlines
        source_code = re.sub(r'\n{3,}', '\n\n', source_code)
        
        return source_code
