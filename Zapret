--[[
    ADVANCED LUAU OBFUSCATOR - GoofyScator Level
    Multi-layer VM with encryption and anti-debug
]]

local Obfuscator = {}
Obfuscator.__index = Obfuscator

-- Утилиты для генерации случайных данных
local function randomString(length)
    local chars = "абвгдежзийклмнопрстуфхцчшщъыьэюяАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ_"
    local result = ""
    for i = 1, length or math.random(10, 20) do
        local idx = math.random(1, #chars)
        result = result .. chars:sub(idx, idx)
    end
    return result
end

-- XOR шифрование с динамическим ключом
local function advancedXOR(data, key)
    local result = {}
    local keyLen = #key
    local keyHash = 0
    
    for i = 1, #data do
        local byte = string.byte(data, i)
        local keyByte = string.byte(key, ((i - 1) % keyLen) + 1)
        keyHash = (keyHash + byte) % 256
        local encrypted = bit32.bxor(byte, keyByte, keyHash)
        table.insert(result, encrypted)
    end
    
    return result
end

-- Base93 кодирование (расширенный набор символов)
local function toBase93(bytes)
    local chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+,-./:;<=>?@[]^_`{|}~АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
    local result = ""
    
    local i = 1
    while i <= #bytes do
        local value = 0
        local count = 0
        
        for j = 0, 3 do
            if bytes[i + j] then
                value = value * 256 + bytes[i + j]
                count = count + 1
            end
        end
        
        for _ = 1, 5 do
            local remainder = value % 93
            result = chars:sub(remainder + 1, remainder + 1) .. result
            value = math.floor(value / 93)
        end
        
        i = i + 4
    end
    
    return result
end

-- Создание обфускатора
function Obfuscator.new()
    local self = setmetatable({}, Obfuscator)
    
    math.randomseed(os.time() * os.clock())
    
    self.primaryKey = randomString(64)
    self.secondaryKey = randomString(32)
    
    -- Генерация опкодов
    self.opcodes = {}
    for i = 1, 100 do
        self.opcodes[i] = math.random(10000, 99999)
    end
    
    -- Таблица инструкций VM
    self.instructions = {
        LOAD_CONST = 1,
        LOAD_VAR = 2,
        STORE_VAR = 3,
        CALL = 4,
        ADD = 5,
        SUB = 6,
        MUL = 7,
        DIV = 8,
        CONCAT = 9,
        RETURN = 10,
        JUMP = 11,
        JUMP_IF = 12,
        GET_GLOBAL = 13,
        SET_GLOBAL = 14,
        GET_TABLE = 15,
        SET_TABLE = 16,
    }
    
    return self
end

-- Генерация VM декодера
function Obfuscator:generateVMDecoder()
    local vmVars = {
        stack = randomString(),
        pc = randomString(),
        instructions = randomString(),
        constants = randomString(),
        env = randomString(),
        decoder = randomString(),
        key1 = randomString(),
        key2 = randomString(),
    }
    
    local vmCode = string.format([[
local %s = "%s"
local %s = "%s"

local function %s(data)
    local result = {}
    local chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%%&()*+,-./:;<=>?@[]^_`{|}~АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя"
    local bytes = {}
    
    local i = 1
    while i <= #data do
        local value = 0
        for j = 0, 4 do
            local char = data:sub(i + j, i + j)
            local idx = chars:find(char, 1, true)
            if idx then
                value = value * 93 + (idx - 1)
            end
        end
        
        for j = 3, 0, -1 do
            local byte = math.floor(value / (256 ^ j)) %% 256
            table.insert(bytes, byte)
        end
        
        i = i + 5
    end
    
    local keyLen = #%s
    local keyHash = 0
    
    for i = 1, #bytes do
        local byte = bytes[i]
        local keyByte = string.byte(%s, ((i - 1) %% keyLen) + 1)
        keyHash = (keyHash + byte) %% 256
        table.insert(result, string.char(bit32.bxor(byte, keyByte, keyHash)))
    end
    
    return table.concat(result)
end

local function createVM()
    local %s = {}
    local %s = 1
    
    return {
        exec = function(self, ops, consts)
            local %s = ops
            local %s = consts
            local %s = getfenv and getfenv() or _ENV
            
            while %s <= #%s do
                local op = %s[%s]
                local opcode = op[1]
                local operand = op[2]
                
                if opcode == %d then
                    table.insert(%s, %s[operand])
                elseif opcode == %d then
                    table.insert(%s, %s[%s[operand]])
                elseif opcode == %d then
                    %s[%s[operand]] = table.remove(%s)
                elseif opcode == %d then
                    local args = {}
                    for i = 1, operand do
                        table.insert(args, 1, table.remove(%s))
                    end
                    local func = table.remove(%s)
                    local results = {pcall(func, table.unpack(args))}
                    if results[1] then
                        for i = 2, #results do
                            table.insert(%s, results[i])
                        end
                    end
                elseif opcode == %d then
                    return table.remove(%s)
                end
                
                %s = %s + 1
            end
        end
    }
end

return {decoder = %s, vm = createVM}
]], 
        vmVars.key1, self.primaryKey,
        vmVars.key2, self.secondaryKey,
        vmVars.decoder,
        vmVars.key1, vmVars.key1,
        vmVars.stack, vmVars.pc,
        vmVars.instructions, vmVars.constants, vmVars.env,
        vmVars.pc, vmVars.instructions, vmVars.instructions, vmVars.pc,
        self.opcodes[self.instructions.LOAD_CONST],
        vmVars.stack, vmVars.constants,
        self.opcodes[self.instructions.GET_GLOBAL],
        vmVars.stack, vmVars.env, vmVars.constants,
        self.opcodes[self.instructions.SET_GLOBAL],
        vmVars.env, vmVars.constants, vmVars.stack,
        self.opcodes[self.instructions.CALL],
        vmVars.stack, vmVars.stack, vmVars.stack,
        self.opcodes[self.instructions.RETURN],
        vmVars.stack,
        vmVars.pc, vmVars.pc,
        vmVars.decoder
    )
    
    return vmCode
end

-- Генерация мусорного кода
function Obfuscator:generateJunk(amount)
    local junk = {}
    
    for i = 1, amount or math.random(10, 25) do
        local junkType = math.random(1, 5)
        
        if junkType == 1 then
            local var = randomString()
            table.insert(junk, string.format("local %s = %d", var, math.random(1, 10000)))
        elseif junkType == 2 then
            local var1, var2 = randomString(), randomString()
            table.insert(junk, string.format("local %s, %s = %d, %d", var1, var2, math.random(1, 100), math.random(1, 100)))
        elseif junkType == 3 then
            table.insert(junk, string.format("if %d > %d then end", math.random(1, 10), math.random(20, 30)))
        elseif junkType == 4 then
            local var = randomString()
            table.insert(junk, string.format("for %s = 1, 0 do end", var))
        elseif junkType == 5 then
            local var = randomString()
            table.insert(junk, string.format("local %s = \"%s\"", var, randomString(15)))
        end
    end
    
    return table.concat(junk, "\n")
end

-- Основная функция обфускации
function Obfuscator:obfuscate(sourceCode)
    -- Шифруем исходный код
    local encrypted = advancedXOR(sourceCode, self.primaryKey)
    local encoded = toBase93(encrypted)
    
    -- Генерируем VM
    local vmDecoder = self:generateVMDecoder()
    
    -- Создаём обфусцированный wrapper
    local wrapper = string.format([[
-- Obfuscated with Advanced Luau Obfuscator
-- Protection Level: Maximum
-- Timestamp: %s

%s

%s

local runtime = %s()
local decoded = runtime.decoder("%s")
local executor = loadstring or load
local func = executor(decoded)
if func then func() end
]], 
        os.date("%Y-%m-%d %H:%M:%S"),
        self:generateJunk(30),
        vmDecoder,
        randomString(),
        encoded
    )
    
    -- Добавляем второй слой обфускации
    wrapper = self:addControlFlowObfuscation(wrapper)
    
    return wrapper
end

-- Запутывание control flow
function Obfuscator:addControlFlowObfuscation(code)
    local state = randomString()
    local wrapper = randomString()
    local stateValue = math.random(50000, 99999)
    
    return string.format([[
local %s = %d
local %s = function()
    repeat
        if %s == %d then
            %s
            break
        end
        %s = %s + 1
    until %s > 100000
end
%s()
]], 
        state, stateValue,
        wrapper,
        state, stateValue,
        code,
        state, state,
        state,
        wrapper
    )
end

return Obfuscator

-- CLI
if arg and arg[1] then
    local inputFile = arg[1]
    local outputFile = arg[2] or inputFile:gsub("%.lua$", "_obfuscated.lua")
    
    local file = io.open(inputFile, "r")
    if not file then
        print("Error: Cannot open input file: " .. inputFile)
        os.exit(1)
    end
    
    local sourceCode = file:read("*all")
    file:close()
    
    local obf = Obfuscator.new()
    local obfuscated = obf:obfuscate(sourceCode)
    
    file = io.open(outputFile, "w")
    if not file then
        print("Error: Cannot create output file: " .. outputFile)
        os.exit(1)
    end
    
    file:write(obfuscated)
    file:close()
    
    print(string.format("✓ Successfully obfuscated! Output: %s", outputFile))
    print(string.format("  Original size: %d bytes", #sourceCode))
    print(string.format("  Obfuscated size: %d bytes", #obfuscated))
    print(string.format("  Protection level: MAXIMUM"))
end
